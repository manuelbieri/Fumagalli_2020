window.pdocSearch = (function(){
/** elasticlunr - http://weixsong.github.io * Copyright (C) 2017 Oliver Nightingale * Copyright (C) 2017 Wei Song * MIT Licensed */!function(){function e(e){if(null===e||"object"!=typeof e)return e;var t=e.constructor();for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n]);return t}var t=function(e){var n=new t.Index;return n.pipeline.add(t.trimmer,t.stopWordFilter,t.stemmer),e&&e.call(n,n),n};t.version="0.9.5",lunr=t,t.utils={},t.utils.warn=function(e){return function(t){e.console&&console.warn&&console.warn(t)}}(this),t.utils.toString=function(e){return void 0===e||null===e?"":e.toString()},t.EventEmitter=function(){this.events={}},t.EventEmitter.prototype.addListener=function(){var e=Array.prototype.slice.call(arguments),t=e.pop(),n=e;if("function"!=typeof t)throw new TypeError("last argument must be a function");n.forEach(function(e){this.hasHandler(e)||(this.events[e]=[]),this.events[e].push(t)},this)},t.EventEmitter.prototype.removeListener=function(e,t){if(this.hasHandler(e)){var n=this.events[e].indexOf(t);-1!==n&&(this.events[e].splice(n,1),0==this.events[e].length&&delete this.events[e])}},t.EventEmitter.prototype.emit=function(e){if(this.hasHandler(e)){var t=Array.prototype.slice.call(arguments,1);this.events[e].forEach(function(e){e.apply(void 0,t)},this)}},t.EventEmitter.prototype.hasHandler=function(e){return e in this.events},t.tokenizer=function(e){if(!arguments.length||null===e||void 0===e)return[];if(Array.isArray(e)){var n=e.filter(function(e){return null===e||void 0===e?!1:!0});n=n.map(function(e){return t.utils.toString(e).toLowerCase()});var i=[];return n.forEach(function(e){var n=e.split(t.tokenizer.seperator);i=i.concat(n)},this),i}return e.toString().trim().toLowerCase().split(t.tokenizer.seperator)},t.tokenizer.defaultSeperator=/[\s\-]+/,t.tokenizer.seperator=t.tokenizer.defaultSeperator,t.tokenizer.setSeperator=function(e){null!==e&&void 0!==e&&"object"==typeof e&&(t.tokenizer.seperator=e)},t.tokenizer.resetSeperator=function(){t.tokenizer.seperator=t.tokenizer.defaultSeperator},t.tokenizer.getSeperator=function(){return t.tokenizer.seperator},t.Pipeline=function(){this._queue=[]},t.Pipeline.registeredFunctions={},t.Pipeline.registerFunction=function(e,n){n in t.Pipeline.registeredFunctions&&t.utils.warn("Overwriting existing registered function: "+n),e.label=n,t.Pipeline.registeredFunctions[n]=e},t.Pipeline.getRegisteredFunction=function(e){return e in t.Pipeline.registeredFunctions!=!0?null:t.Pipeline.registeredFunctions[e]},t.Pipeline.warnIfFunctionNotRegistered=function(e){var n=e.label&&e.label in this.registeredFunctions;n||t.utils.warn("Function is not registered with pipeline. This may cause problems when serialising the index.\n",e)},t.Pipeline.load=function(e){var n=new t.Pipeline;return e.forEach(function(e){var i=t.Pipeline.getRegisteredFunction(e);if(!i)throw new Error("Cannot load un-registered function: "+e);n.add(i)}),n},t.Pipeline.prototype.add=function(){var e=Array.prototype.slice.call(arguments);e.forEach(function(e){t.Pipeline.warnIfFunctionNotRegistered(e),this._queue.push(e)},this)},t.Pipeline.prototype.after=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i+1,0,n)},t.Pipeline.prototype.before=function(e,n){t.Pipeline.warnIfFunctionNotRegistered(n);var i=this._queue.indexOf(e);if(-1===i)throw new Error("Cannot find existingFn");this._queue.splice(i,0,n)},t.Pipeline.prototype.remove=function(e){var t=this._queue.indexOf(e);-1!==t&&this._queue.splice(t,1)},t.Pipeline.prototype.run=function(e){for(var t=[],n=e.length,i=this._queue.length,o=0;n>o;o++){for(var r=e[o],s=0;i>s&&(r=this._queue[s](r,o,e),void 0!==r&&null!==r);s++);void 0!==r&&null!==r&&t.push(r)}return t},t.Pipeline.prototype.reset=function(){this._queue=[]},t.Pipeline.prototype.get=function(){return this._queue},t.Pipeline.prototype.toJSON=function(){return this._queue.map(function(e){return t.Pipeline.warnIfFunctionNotRegistered(e),e.label})},t.Index=function(){this._fields=[],this._ref="id",this.pipeline=new t.Pipeline,this.documentStore=new t.DocumentStore,this.index={},this.eventEmitter=new t.EventEmitter,this._idfCache={},this.on("add","remove","update",function(){this._idfCache={}}.bind(this))},t.Index.prototype.on=function(){var e=Array.prototype.slice.call(arguments);return this.eventEmitter.addListener.apply(this.eventEmitter,e)},t.Index.prototype.off=function(e,t){return this.eventEmitter.removeListener(e,t)},t.Index.load=function(e){e.version!==t.version&&t.utils.warn("version mismatch: current "+t.version+" importing "+e.version);var n=new this;n._fields=e.fields,n._ref=e.ref,n.documentStore=t.DocumentStore.load(e.documentStore),n.pipeline=t.Pipeline.load(e.pipeline),n.index={};for(var i in e.index)n.index[i]=t.InvertedIndex.load(e.index[i]);return n},t.Index.prototype.addField=function(e){return this._fields.push(e),this.index[e]=new t.InvertedIndex,this},t.Index.prototype.setRef=function(e){return this._ref=e,this},t.Index.prototype.saveDocument=function(e){return this.documentStore=new t.DocumentStore(e),this},t.Index.prototype.addDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.addDoc(i,e),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));this.documentStore.addFieldLength(i,n,o.length);var r={};o.forEach(function(e){e in r?r[e]+=1:r[e]=1},this);for(var s in r){var u=r[s];u=Math.sqrt(u),this.index[n].addToken(s,{ref:i,tf:u})}},this),n&&this.eventEmitter.emit("add",e,this)}},t.Index.prototype.removeDocByRef=function(e){if(e&&this.documentStore.isDocStored()!==!1&&this.documentStore.hasDoc(e)){var t=this.documentStore.getDoc(e);this.removeDoc(t,!1)}},t.Index.prototype.removeDoc=function(e,n){if(e){var n=void 0===n?!0:n,i=e[this._ref];this.documentStore.hasDoc(i)&&(this.documentStore.removeDoc(i),this._fields.forEach(function(n){var o=this.pipeline.run(t.tokenizer(e[n]));o.forEach(function(e){this.index[n].removeToken(e,i)},this)},this),n&&this.eventEmitter.emit("remove",e,this))}},t.Index.prototype.updateDoc=function(e,t){var t=void 0===t?!0:t;this.removeDocByRef(e[this._ref],!1),this.addDoc(e,!1),t&&this.eventEmitter.emit("update",e,this)},t.Index.prototype.idf=function(e,t){var n="@"+t+"/"+e;if(Object.prototype.hasOwnProperty.call(this._idfCache,n))return this._idfCache[n];var i=this.index[t].getDocFreq(e),o=1+Math.log(this.documentStore.length/(i+1));return this._idfCache[n]=o,o},t.Index.prototype.getFields=function(){return this._fields.slice()},t.Index.prototype.search=function(e,n){if(!e)return[];e="string"==typeof e?{any:e}:JSON.parse(JSON.stringify(e));var i=null;null!=n&&(i=JSON.stringify(n));for(var o=new t.Configuration(i,this.getFields()).get(),r={},s=Object.keys(e),u=0;u<s.length;u++){var a=s[u];r[a]=this.pipeline.run(t.tokenizer(e[a]))}var l={};for(var c in o){var d=r[c]||r.any;if(d){var f=this.fieldSearch(d,c,o),h=o[c].boost;for(var p in f)f[p]=f[p]*h;for(var p in f)p in l?l[p]+=f[p]:l[p]=f[p]}}var v,g=[];for(var p in l)v={ref:p,score:l[p]},this.documentStore.hasDoc(p)&&(v.doc=this.documentStore.getDoc(p)),g.push(v);return g.sort(function(e,t){return t.score-e.score}),g},t.Index.prototype.fieldSearch=function(e,t,n){var i=n[t].bool,o=n[t].expand,r=n[t].boost,s=null,u={};return 0!==r?(e.forEach(function(e){var n=[e];1==o&&(n=this.index[t].expandToken(e));var r={};n.forEach(function(n){var o=this.index[t].getDocs(n),a=this.idf(n,t);if(s&&"AND"==i){var l={};for(var c in s)c in o&&(l[c]=o[c]);o=l}n==e&&this.fieldSearchStats(u,n,o);for(var c in o){var d=this.index[t].getTermFrequency(n,c),f=this.documentStore.getFieldLength(c,t),h=1;0!=f&&(h=1/Math.sqrt(f));var p=1;n!=e&&(p=.15*(1-(n.length-e.length)/n.length));var v=d*a*h*p;c in r?r[c]+=v:r[c]=v}},this),s=this.mergeScores(s,r,i)},this),s=this.coordNorm(s,u,e.length)):void 0},t.Index.prototype.mergeScores=function(e,t,n){if(!e)return t;if("AND"==n){var i={};for(var o in t)o in e&&(i[o]=e[o]+t[o]);return i}for(var o in t)o in e?e[o]+=t[o]:e[o]=t[o];return e},t.Index.prototype.fieldSearchStats=function(e,t,n){for(var i in n)i in e?e[i].push(t):e[i]=[t]},t.Index.prototype.coordNorm=function(e,t,n){for(var i in e)if(i in t){var o=t[i].length;e[i]=e[i]*o/n}return e},t.Index.prototype.toJSON=function(){var e={};return this._fields.forEach(function(t){e[t]=this.index[t].toJSON()},this),{version:t.version,fields:this._fields,ref:this._ref,documentStore:this.documentStore.toJSON(),index:e,pipeline:this.pipeline.toJSON()}},t.Index.prototype.use=function(e){var t=Array.prototype.slice.call(arguments,1);t.unshift(this),e.apply(this,t)},t.DocumentStore=function(e){this._save=null===e||void 0===e?!0:e,this.docs={},this.docInfo={},this.length=0},t.DocumentStore.load=function(e){var t=new this;return t.length=e.length,t.docs=e.docs,t.docInfo=e.docInfo,t._save=e.save,t},t.DocumentStore.prototype.isDocStored=function(){return this._save},t.DocumentStore.prototype.addDoc=function(t,n){this.hasDoc(t)||this.length++,this.docs[t]=this._save===!0?e(n):null},t.DocumentStore.prototype.getDoc=function(e){return this.hasDoc(e)===!1?null:this.docs[e]},t.DocumentStore.prototype.hasDoc=function(e){return e in this.docs},t.DocumentStore.prototype.removeDoc=function(e){this.hasDoc(e)&&(delete this.docs[e],delete this.docInfo[e],this.length--)},t.DocumentStore.prototype.addFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&(this.docInfo[e]||(this.docInfo[e]={}),this.docInfo[e][t]=n)},t.DocumentStore.prototype.updateFieldLength=function(e,t,n){null!==e&&void 0!==e&&0!=this.hasDoc(e)&&this.addFieldLength(e,t,n)},t.DocumentStore.prototype.getFieldLength=function(e,t){return null===e||void 0===e?0:e in this.docs&&t in this.docInfo[e]?this.docInfo[e][t]:0},t.DocumentStore.prototype.toJSON=function(){return{docs:this.docs,docInfo:this.docInfo,length:this.length,save:this._save}},t.stemmer=function(){var e={ational:"ate",tional:"tion",enci:"ence",anci:"ance",izer:"ize",bli:"ble",alli:"al",entli:"ent",eli:"e",ousli:"ous",ization:"ize",ation:"ate",ator:"ate",alism:"al",iveness:"ive",fulness:"ful",ousness:"ous",aliti:"al",iviti:"ive",biliti:"ble",logi:"log"},t={icate:"ic",ative:"",alize:"al",iciti:"ic",ical:"ic",ful:"",ness:""},n="[^aeiou]",i="[aeiouy]",o=n+"[^aeiouy]*",r=i+"[aeiou]*",s="^("+o+")?"+r+o,u="^("+o+")?"+r+o+"("+r+")?$",a="^("+o+")?"+r+o+r+o,l="^("+o+")?"+i,c=new RegExp(s),d=new RegExp(a),f=new RegExp(u),h=new RegExp(l),p=/^(.+?)(ss|i)es$/,v=/^(.+?)([^s])s$/,g=/^(.+?)eed$/,m=/^(.+?)(ed|ing)$/,y=/.$/,S=/(at|bl|iz)$/,x=new RegExp("([^aeiouylsz])\\1$"),w=new RegExp("^"+o+i+"[^aeiouwxy]$"),I=/^(.+?[^aeiou])y$/,b=/^(.+?)(ational|tional|enci|anci|izer|bli|alli|entli|eli|ousli|ization|ation|ator|alism|iveness|fulness|ousness|aliti|iviti|biliti|logi)$/,E=/^(.+?)(icate|ative|alize|iciti|ical|ful|ness)$/,D=/^(.+?)(al|ance|ence|er|ic|able|ible|ant|ement|ment|ent|ou|ism|ate|iti|ous|ive|ize)$/,F=/^(.+?)(s|t)(ion)$/,_=/^(.+?)e$/,P=/ll$/,k=new RegExp("^"+o+i+"[^aeiouwxy]$"),z=function(n){var i,o,r,s,u,a,l;if(n.length<3)return n;if(r=n.substr(0,1),"y"==r&&(n=r.toUpperCase()+n.substr(1)),s=p,u=v,s.test(n)?n=n.replace(s,"$1$2"):u.test(n)&&(n=n.replace(u,"$1$2")),s=g,u=m,s.test(n)){var z=s.exec(n);s=c,s.test(z[1])&&(s=y,n=n.replace(s,""))}else if(u.test(n)){var z=u.exec(n);i=z[1],u=h,u.test(i)&&(n=i,u=S,a=x,l=w,u.test(n)?n+="e":a.test(n)?(s=y,n=n.replace(s,"")):l.test(n)&&(n+="e"))}if(s=I,s.test(n)){var z=s.exec(n);i=z[1],n=i+"i"}if(s=b,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+e[o])}if(s=E,s.test(n)){var z=s.exec(n);i=z[1],o=z[2],s=c,s.test(i)&&(n=i+t[o])}if(s=D,u=F,s.test(n)){var z=s.exec(n);i=z[1],s=d,s.test(i)&&(n=i)}else if(u.test(n)){var z=u.exec(n);i=z[1]+z[2],u=d,u.test(i)&&(n=i)}if(s=_,s.test(n)){var z=s.exec(n);i=z[1],s=d,u=f,a=k,(s.test(i)||u.test(i)&&!a.test(i))&&(n=i)}return s=P,u=d,s.test(n)&&u.test(n)&&(s=y,n=n.replace(s,"")),"y"==r&&(n=r.toLowerCase()+n.substr(1)),n};return z}(),t.Pipeline.registerFunction(t.stemmer,"stemmer"),t.stopWordFilter=function(e){return e&&t.stopWordFilter.stopWords[e]!==!0?e:void 0},t.clearStopWords=function(){t.stopWordFilter.stopWords={}},t.addStopWords=function(e){null!=e&&Array.isArray(e)!==!1&&e.forEach(function(e){t.stopWordFilter.stopWords[e]=!0},this)},t.resetStopWords=function(){t.stopWordFilter.stopWords=t.defaultStopWords},t.defaultStopWords={"":!0,a:!0,able:!0,about:!0,across:!0,after:!0,all:!0,almost:!0,also:!0,am:!0,among:!0,an:!0,and:!0,any:!0,are:!0,as:!0,at:!0,be:!0,because:!0,been:!0,but:!0,by:!0,can:!0,cannot:!0,could:!0,dear:!0,did:!0,"do":!0,does:!0,either:!0,"else":!0,ever:!0,every:!0,"for":!0,from:!0,get:!0,got:!0,had:!0,has:!0,have:!0,he:!0,her:!0,hers:!0,him:!0,his:!0,how:!0,however:!0,i:!0,"if":!0,"in":!0,into:!0,is:!0,it:!0,its:!0,just:!0,least:!0,let:!0,like:!0,likely:!0,may:!0,me:!0,might:!0,most:!0,must:!0,my:!0,neither:!0,no:!0,nor:!0,not:!0,of:!0,off:!0,often:!0,on:!0,only:!0,or:!0,other:!0,our:!0,own:!0,rather:!0,said:!0,say:!0,says:!0,she:!0,should:!0,since:!0,so:!0,some:!0,than:!0,that:!0,the:!0,their:!0,them:!0,then:!0,there:!0,these:!0,they:!0,"this":!0,tis:!0,to:!0,too:!0,twas:!0,us:!0,wants:!0,was:!0,we:!0,were:!0,what:!0,when:!0,where:!0,which:!0,"while":!0,who:!0,whom:!0,why:!0,will:!0,"with":!0,would:!0,yet:!0,you:!0,your:!0},t.stopWordFilter.stopWords=t.defaultStopWords,t.Pipeline.registerFunction(t.stopWordFilter,"stopWordFilter"),t.trimmer=function(e){if(null===e||void 0===e)throw new Error("token should not be undefined");return e.replace(/^\W+/,"").replace(/\W+$/,"")},t.Pipeline.registerFunction(t.trimmer,"trimmer"),t.InvertedIndex=function(){this.root={docs:{},df:0}},t.InvertedIndex.load=function(e){var t=new this;return t.root=e.root,t},t.InvertedIndex.prototype.addToken=function(e,t,n){for(var n=n||this.root,i=0;i<=e.length-1;){var o=e[i];o in n||(n[o]={docs:{},df:0}),i+=1,n=n[o]}var r=t.ref;n.docs[r]?n.docs[r]={tf:t.tf}:(n.docs[r]={tf:t.tf},n.df+=1)},t.InvertedIndex.prototype.hasToken=function(e){if(!e)return!1;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return!1;t=t[e[n]]}return!0},t.InvertedIndex.prototype.getNode=function(e){if(!e)return null;for(var t=this.root,n=0;n<e.length;n++){if(!t[e[n]])return null;t=t[e[n]]}return t},t.InvertedIndex.prototype.getDocs=function(e){var t=this.getNode(e);return null==t?{}:t.docs},t.InvertedIndex.prototype.getTermFrequency=function(e,t){var n=this.getNode(e);return null==n?0:t in n.docs?n.docs[t].tf:0},t.InvertedIndex.prototype.getDocFreq=function(e){var t=this.getNode(e);return null==t?0:t.df},t.InvertedIndex.prototype.removeToken=function(e,t){if(e){var n=this.getNode(e);null!=n&&t in n.docs&&(delete n.docs[t],n.df-=1)}},t.InvertedIndex.prototype.expandToken=function(e,t,n){if(null==e||""==e)return[];var t=t||[];if(void 0==n&&(n=this.getNode(e),null==n))return t;n.df>0&&t.push(e);for(var i in n)"docs"!==i&&"df"!==i&&this.expandToken(e+i,t,n[i]);return t},t.InvertedIndex.prototype.toJSON=function(){return{root:this.root}},t.Configuration=function(e,n){var e=e||"";if(void 0==n||null==n)throw new Error("fields should not be null");this.config={};var i;try{i=JSON.parse(e),this.buildUserConfig(i,n)}catch(o){t.utils.warn("user configuration parse failed, will use default configuration"),this.buildDefaultConfig(n)}},t.Configuration.prototype.buildDefaultConfig=function(e){this.reset(),e.forEach(function(e){this.config[e]={boost:1,bool:"OR",expand:!1}},this)},t.Configuration.prototype.buildUserConfig=function(e,n){var i="OR",o=!1;if(this.reset(),"bool"in e&&(i=e.bool||i),"expand"in e&&(o=e.expand||o),"fields"in e)for(var r in e.fields)if(n.indexOf(r)>-1){var s=e.fields[r],u=o;void 0!=s.expand&&(u=s.expand),this.config[r]={boost:s.boost||0===s.boost?s.boost:1,bool:s.bool||i,expand:u}}else t.utils.warn("field name in user configuration not found in index instance fields");else this.addAllFields2UserConfig(i,o,n)},t.Configuration.prototype.addAllFields2UserConfig=function(e,t,n){n.forEach(function(n){this.config[n]={boost:1,bool:e,expand:t}},this)},t.Configuration.prototype.get=function(){return this.config},t.Configuration.prototype.reset=function(){this.config={}},lunr.SortedSet=function(){this.length=0,this.elements=[]},lunr.SortedSet.load=function(e){var t=new this;return t.elements=e,t.length=e.length,t},lunr.SortedSet.prototype.add=function(){var e,t;for(e=0;e<arguments.length;e++)t=arguments[e],~this.indexOf(t)||this.elements.splice(this.locationFor(t),0,t);this.length=this.elements.length},lunr.SortedSet.prototype.toArray=function(){return this.elements.slice()},lunr.SortedSet.prototype.map=function(e,t){return this.elements.map(e,t)},lunr.SortedSet.prototype.forEach=function(e,t){return this.elements.forEach(e,t)},lunr.SortedSet.prototype.indexOf=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;){if(r===e)return o;e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o]}return r===e?o:-1},lunr.SortedSet.prototype.locationFor=function(e){for(var t=0,n=this.elements.length,i=n-t,o=t+Math.floor(i/2),r=this.elements[o];i>1;)e>r&&(t=o),r>e&&(n=o),i=n-t,o=t+Math.floor(i/2),r=this.elements[o];return r>e?o:e>r?o+1:void 0},lunr.SortedSet.prototype.intersect=function(e){for(var t=new lunr.SortedSet,n=0,i=0,o=this.length,r=e.length,s=this.elements,u=e.elements;;){if(n>o-1||i>r-1)break;s[n]!==u[i]?s[n]<u[i]?n++:s[n]>u[i]&&i++:(t.add(s[n]),n++,i++)}return t},lunr.SortedSet.prototype.clone=function(){var e=new lunr.SortedSet;return e.elements=this.toArray(),e.length=e.elements.length,e},lunr.SortedSet.prototype.union=function(e){var t,n,i;this.length>=e.length?(t=this,n=e):(t=e,n=this),i=t.clone();for(var o=0,r=n.toArray();o<r.length;o++)i.add(r[o]);return i},lunr.SortedSet.prototype.toJSON=function(){return this.toArray()},function(e,t){"function"==typeof define&&define.amd?define(t):"object"==typeof exports?module.exports=t():e.elasticlunr=t()}(this,function(){return t})}();
    /** pdoc search index */const docs = [{"fullname": "Fumagalli_Motta_Tarantino_2020", "modulename": "Fumagalli_Motta_Tarantino_2020", "type": "module", "doc": "<p><a href=\"https://github.com/manuelbieri/Fumagalli_2020/actions/workflows/CodeCov.yml\"><img src=\"https://github.com/manuelbieri/Fumagalli_2020/actions/workflows/CodeCov.yml/badge.svg\" alt=\"CI\" /></a>\n<a href=\"https://codecov.io/gh/manuelbieri/Fumagalli_2020\"><img src=\"https://codecov.io/gh/manuelbieri/Fumagalli_2020/branch/master/graph/badge.svg?token=RRZ3PJI9U1\" alt=\"codecov\" /></a>\n<a href=\"https://github.com/manuelbieri/Fumagalli_2020/actions/workflows/codeql-analysis.yml\"><img src=\"https://github.com/manuelbieri/Fumagalli_2020/actions/workflows/codeql-analysis.yml/badge.svg\" alt=\"CodeQL\" /></a>\n<a href=\"https://github.com/manuelbieri/Fumagalli_2020/actions/workflows/Black.yml\"><img src=\"https://github.com/manuelbieri/Fumagalli_2020/actions/workflows/Black.yml/badge.svg\" alt=\"Code Style Check\" /></a>\n<a href=\"https://www.codefactor.io/repository/github/manuelbieri/fumagalli_2020\"><img src=\"https://www.codefactor.io/repository/github/manuelbieri/fumagalli_2020/badge\" alt=\"CodeFactor\" /></a>\n<a href=\"https://github.com/manuelbieri/Fumagalli_2020\"><img src=\"https://img.shields.io/github/repo-size/manuelbieri/Fumagalli_2020\" alt=\"GitHub repo size\" /></a>\n<a href=\"https://github.com/manuelbieri/Fumagalli_2020/blob/master/LICENSE\"><img src=\"https://img.shields.io/github/license/manuelbieri/Fumagalli_2020\" alt=\"GitHub license\" /></a>\n<a href=\"https://github.com/manuelbieri/Fumagalli_2020/releases\"><img src=\"https://img.shields.io/github/v/release/manuelbieri/Fumagalli_2020\" alt=\"GitHub release (latest by date)\" /></a>\n<img src=\"https://img.shields.io/pypi/status/Fumagalli-Motta-Tarantino-2020\" alt=\"PyPI - Status\" />\n<img src=\"https://img.shields.io/pypi/pyversions/Fumagalli-Motta-Tarantino-2020\" alt=\"PyPI - Python Version\" />\n<a href=\"https://share.streamlit.io/manuelbieri/fmt20web/fmt20_app.py\"><img src=\"https://static.streamlit.io/badges/streamlit_badge_black_white.svg\" alt=\"Streamlit App\" /></a></p>\n\n<h3 id=\"installation\">Installation</h3>\n\n<p>Install the latest release from <a href=\"https://pypi.org/project/Fumagalli-Motta-Tarantino-2020/\">PyPi</a>:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>$ pip install Fumagalli-Motta-Tarantino-2020\n</code></pre></div>\n\n<p>Or alternatively, install the package directly from source:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>$ pip install git+https://github.com/manuelbieri/Fumagalli_2020.git\n</code></pre></div>\n\n<h3 id=\"basic-usage\">Basic Usage</h3>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"kn\">import</span> <span class=\"nn\">Fumagalli_Motta_Tarantino_2020</span> <span class=\"k\">as</span> <span class=\"nn\">FMT20</span>\n\n<span class=\"c1\"># initialize the model (here you can adjust the parameters of the model)</span>\n<span class=\"c1\"># all other models conform to the interface defined in FMT20.OptimalMergerPolicy</span>\n<span class=\"n\">model</span><span class=\"p\">:</span> <span class=\"n\">FMT20</span><span class=\"o\">.</span><span class=\"n\">OptimalMergerPolicy</span> <span class=\"o\">=</span> <span class=\"n\">FMT20</span><span class=\"o\">.</span><span class=\"n\">OptimalMergerPolicy</span><span class=\"p\">()</span>\n\n<span class=\"c1\"># print a summary of the outcome</span>\n<span class=\"nb\">print</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"o\">.</span><span class=\"n\">summary</span><span class=\"p\">())</span>\n\n<span class=\"c1\"># plot a model overview</span>\n<span class=\"n\">FMT20</span><span class=\"o\">.</span><span class=\"n\">Overview</span><span class=\"p\">(</span><span class=\"n\">model</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">show</span><span class=\"p\">()</span>\n</code></pre></div>\n\n<p>A tutorial is included with the notebook tutorial.ipynb. Additionally, find the latest documentation including all the details on <a href=\"https://manuelbieri.ch/Fumagalli_2020/\">manuelbieri.ch/fumagalli_2020</a>.</p>\n\n<p>Note: mybinder.org is currently not supported, since the package needs at least python 3.9.</p>\n\n<h3 id=\"dependencies\">Dependencies</h3>\n\n<p>Install the dependencies with the following command (Note: Make sure you are operating in the same directory, where the \n<code>requirements.txt</code> is located.):</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>$ pip install -r requirements.txt\n</code></pre></div>\n\n<h3 id=\"tests\">Tests</h3>\n\n<p>Run the unittests shipped in Fumagalli_Motta_Tarantino_2020.tests with the following command (pay attention to the current working directory):</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>$ python -m unittest discover Fumagalli_Motta_Tarantino_2020/tests\n</code></pre></div>\n\n<p>For explanations about the tests, have a look at <a href=\"Fumagalli_Motta_Tarantino_2020/tests/TestCases.md\">TestCases.md</a> . See <a href=\"https://app.codecov.io/gh/manuelbieri/Fumagalli_2020\">codecov.io</a> for a detailed report about the test coverage.</p>\n\n<h3 id=\"generate-documentation\">Generate Documentation</h3>\n\n<p>Generate the documentation with the following command:</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>$ pdoc -o docs Fumagalli_Motta_Tarantino_2020 --docformat numpy --math\n</code></pre></div>\n\n<p>or run the shell-script <code>docs/build.sh</code> in the terminal.</p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.CournotCompetition", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "CournotCompetition", "type": "class", "doc": "<p>Add functionality to determine the optimal merger policy for a given set of parameters.</p>\n\n<p>Annotation: As discussed in section 5.1, a policy that is more lenient with respect to early acquisitions is always\ndominated by a strict merger policy. Therefore, only the three remaining policies are discussed.</p>\n", "bases": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.CournotCompetition.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "CournotCompetition.__init__", "type": "function", "doc": "<p>Takes the same arguments as BaseModel.__init__.</p>\n", "signature": "(self, gamma=0.3, *args, **kwargs)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.CournotCompetition.incumbent_expected_additional_profit_from_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "CournotCompetition.incumbent_expected_additional_profit_from_innovation", "type": "function", "doc": "<p>Returns the additional expected profit for the incumbent, if it does not shelve the product after an acquisition.</p>\n\n<p>$ Expected \\; additional \\; profit = p*(\\pi^M_I-\\pi^m_I)-K$</p>\n", "signature": "(self) -> float", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.CournotCompetition.asset_threshold", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "CournotCompetition.asset_threshold", "type": "variable", "doc": "<p>Threshold level $\\bar{A} = B - (\\pi^d_S - K)$</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.CournotCompetition.gamma", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "CournotCompetition.gamma", "type": "variable", "doc": "<p></p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.CournotCompetition.is_laissez_faire_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "CournotCompetition.is_laissez_faire_optimal", "type": "function", "doc": "<p>Returns whether a laissez-faire policy is optimal.</p>\n\n<p>A laissez-faire policy (that authorises any takeover) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Financial imperfections are severe ($F(\\bar{A}^T)\\ge\\Phi^T(\\cdot)$).</li>\n<li>Approving early takeovers followed by shelving is optimal ($F(\\bar{A}^T)\\ge\\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If a laissez-faire merger policy is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.CournotCompetition.is_intermediate_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "CournotCompetition.is_intermediate_optimal", "type": "function", "doc": "<p>Returns whether an intermediate merger policy (late takeover allowed) is optimal.</p>\n\n<p>An intermediate merger policy (late takeovers allowed) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Approving early takeovers followed by shelving is not optimal ($F(\\bar{A}^T) &lt; \\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If an intermediate merger policy (late takeover allowed) is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.CournotCompetition.is_strict_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "CournotCompetition.is_strict_optimal", "type": "function", "doc": "<p>Returns whether the strict merger policy is optimal.</p>\n\n<p>The strict merger is optimal, if the other policies are not optimal.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If the strict merger policy is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.CournotCompetition.is_investment_cost_sufficiently_high", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "CournotCompetition.is_investment_cost_sufficiently_high", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.CournotCompetition.is_degree_substitutability_moderate", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "CournotCompetition.is_degree_substitutability_moderate", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.PerfectInformation", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "PerfectInformation", "type": "class", "doc": "<p>Add functionality to determine the optimal merger policy for a given set of parameters.</p>\n\n<p>Annotation: As discussed in section 5.1, a policy that is more lenient with respect to early acquisitions is always\ndominated by a strict merger policy. Therefore, only the three remaining policies are discussed.</p>\n", "bases": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.PerfectInformation.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "PerfectInformation.__init__", "type": "function", "doc": "<p>Takes the same arguments as BaseModel.__init__.</p>\n", "signature": "(\n    self,\n    merger_policy: Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies = <MergerPolicies.Strict: 'Strict'>,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.PerfectInformation.is_laissez_faire_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "PerfectInformation.is_laissez_faire_optimal", "type": "function", "doc": "<p>Returns whether a laissez-faire policy is optimal.</p>\n\n<p>A laissez-faire policy (that authorises any takeover) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Financial imperfections are severe ($F(\\bar{A}^T)\\ge\\Phi^T(\\cdot)$).</li>\n<li>Approving early takeovers followed by shelving is optimal ($F(\\bar{A}^T)\\ge\\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If a laissez-faire merger policy is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.PerfectInformation.is_intermediate_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "PerfectInformation.is_intermediate_optimal", "type": "function", "doc": "<p>Returns whether an intermediate merger policy (late takeover allowed) is optimal.</p>\n\n<p>An intermediate merger policy (late takeovers allowed) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Approving early takeovers followed by shelving is not optimal ($F(\\bar{A}^T) &lt; \\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If an intermediate merger policy (late takeover allowed) is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.EquityContract", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "EquityContract", "type": "class", "doc": "<p>Add functionality to determine the optimal merger policy for a given set of parameters.</p>\n\n<p>Annotation: As discussed in section 5.1, a policy that is more lenient with respect to early acquisitions is always\ndominated by a strict merger policy. Therefore, only the three remaining policies are discussed.</p>\n", "bases": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.EquityContract.asset_threshold_late_takeover", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "EquityContract.asset_threshold_late_takeover", "type": "variable", "doc": "<p>The prospect that the start-up will be acquired at $t = 2$ alleviates financial constraints: there exists a\nthreshold level $\\bar{A}^T = B - (\\pi_I^M - K)$</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.EquityContract.does_startup_strictly_prefer_debt", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "EquityContract.does_startup_strictly_prefer_debt", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.EquityContract.is_intermediate_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "EquityContract.is_intermediate_optimal", "type": "function", "doc": "<p>Returns whether an intermediate merger policy (late takeover allowed) is optimal.</p>\n\n<p>An intermediate merger policy (late takeovers allowed) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Approving early takeovers followed by shelving is not optimal ($F(\\bar{A}^T) &lt; \\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If an intermediate merger policy (late takeover allowed) is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.AdditionalModels.EquityContract.is_laissez_faire_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.AdditionalModels", "qualname": "EquityContract.is_laissez_faire_optimal", "type": "function", "doc": "<p>Returns whether a laissez-faire policy is optimal.</p>\n\n<p>A laissez-faire policy (that authorises any takeover) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Financial imperfections are severe ($F(\\bar{A}^T)\\ge\\Phi^T(\\cdot)$).</li>\n<li>Approving early takeovers followed by shelving is optimal ($F(\\bar{A}^T)\\ge\\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If a laissez-faire merger policy is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Configurations", "modulename": "Fumagalli_Motta_Tarantino_2020.Configurations", "type": "module", "doc": "<h1 id=\"preset-configurations\">Preset Configurations</h1>\n\n<p>To make the life of the user easier, here are some predefined configuration of parameters with specific characteristics.</p>\n\n<h2 id=\"how-to-use\">How to use</h2>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code><span class=\"kn\">from</span> <span class=\"nn\">Fumagalli_Motta_Tarantino_2020</span> <span class=\"kn\">import</span> <span class=\"o\">*</span>\n\n<span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"n\">Config</span><span class=\"o\">.</span><span class=\"n\">LoadParameters</span><span class=\"p\">(</span><span class=\"n\">config_id</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span> <span class=\"c1\"># load configuration</span>\n<span class=\"n\">model</span> <span class=\"o\">=</span> <span class=\"n\">OptimalMergerPolicy</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">params</span><span class=\"p\">())</span> <span class=\"c1\"># Do not forget the stars in front of the call</span>\n\n<span class=\"c1\"># Advanced use</span>\n<span class=\"n\">params</span> <span class=\"o\">=</span> <span class=\"n\">Config</span><span class=\"o\">.</span><span class=\"n\">LoadParameters</span><span class=\"p\">(</span><span class=\"n\">config_id</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"n\">params</span><span class=\"o\">.</span><span class=\"n\">adjust_parameters</span><span class=\"p\">(</span><span class=\"n\">development_costs</span><span class=\"o\">=</span><span class=\"mf\">0.11</span><span class=\"p\">)</span> <span class=\"c1\"># change parameters in the configuration</span>\n<span class=\"n\">params</span><span class=\"o\">.</span><span class=\"n\">set_merger_policy</span><span class=\"p\">(</span><span class=\"n\">Types</span><span class=\"o\">.</span><span class=\"n\">MergerPolicies</span><span class=\"o\">.</span><span class=\"n\">Laissez_faire</span><span class=\"p\">)</span> <span class=\"c1\"># change merger policy</span>\n<span class=\"n\">params</span><span class=\"o\">.</span><span class=\"n\">toggle_development_success</span><span class=\"p\">()</span> <span class=\"c1\"># change the development outcome to the opposite</span>\n<span class=\"n\">model_with_adjustments</span> <span class=\"o\">=</span> <span class=\"n\">OptimalMergerPolicy</span><span class=\"p\">(</span><span class=\"o\">**</span><span class=\"n\">params</span><span class=\"p\">())</span>\n</code></pre></div>\n\n<p>Change the <code>config_id</code> argument for a different configuration of parameters.</p>\n\n<h2 id=\"available-configurations\">Available Configurations</h2>\n\n<p>See Fumagalli_Motta_Tarantino_2020.Models.BaseModel for the definition of the thresholds.</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:center;\">ID</th>\n  <th style=\"text-align:center;\">Shelving</th>\n  <th style=\"text-align:center;\">$F(\\bar{A}) &gt; \\Gamma(\\cdot)$</th>\n  <th style=\"text-align:center;\">$F(\\bar{A}) &gt; \\Phi(\\cdot)$</th>\n  <th style=\"text-align:center;\">$F(\\bar{A}) &gt; \\Phi'(\\cdot)$</th>\n  <th style=\"text-align:center;\">$F(\\bar{A}^T) &gt; \\Phi^T(\\cdot)$</th>\n  <th style=\"text-align:left;\">Optimized for</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:center;\">1</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:left;\">OptimalMerger</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">2</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:left;\">OptimalMerger</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">3</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:left;\">OptimalMerger</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">4</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:left;\">OptimalMerger</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">5</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:left;\">OptimalMerger</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">30</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:left;\">ProCompetitive</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">31</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:left;\">ProCompetitive</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">32</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:left;\">ProCompetitive</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">33</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:left;\">ResourceWaste</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">34</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:left;\">ResourceWaste</td>\n</tr>\n<tr>\n  <td style=\"text-align:center;\">35</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:left;\">ResourceWaste</td>\n</tr>\n</tbody>\n</table>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Configurations.ConfigExceptions", "modulename": "Fumagalli_Motta_Tarantino_2020.Configurations.ConfigExceptions", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Configurations.ConfigExceptions.IDNotAvailableError", "modulename": "Fumagalli_Motta_Tarantino_2020.Configurations.ConfigExceptions", "qualname": "IDNotAvailableError", "type": "class", "doc": "<p>Method or function hasn't been implemented yet.</p>\n", "bases": "builtins.NotImplementedError"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig", "modulename": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig.LoadParameters", "modulename": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig", "qualname": "LoadParameters", "type": "class", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig.LoadParameters.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig", "qualname": "LoadParameters.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, config_id: int, file_path: Optional[str] = None)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig.LoadParameters.file_name", "modulename": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig", "qualname": "LoadParameters.file_name", "type": "variable", "doc": "<p></p>\n", "annotation": ": str", "default_value": " = 'params.csv'"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig.LoadParameters.adjust_parameters", "modulename": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig", "qualname": "LoadParameters.adjust_parameters", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig.LoadParameters.toggle_development_success", "modulename": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig", "qualname": "LoadParameters.toggle_development_success", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig.LoadParameters.set_startup_assets", "modulename": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig", "qualname": "LoadParameters.set_startup_assets", "type": "function", "doc": "<p></p>\n", "signature": "(self, value: float)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig.LoadParameters.set_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.Configurations.LoadConfig", "qualname": "LoadParameters.set_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self, value: Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Distributions", "modulename": "Fumagalli_Motta_Tarantino_2020.Distributions", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Distributions.NormalDistribution", "modulename": "Fumagalli_Motta_Tarantino_2020.Distributions", "qualname": "NormalDistribution", "type": "class", "doc": "<p>Represents a normal distribution function.</p>\n\n<p>Parameters for the distribution:</p>\n\n<ul>\n<li>loc: mean of the normal  distribution</li>\n<li>scale: standard deviation of the normal distribution</li>\n</ul>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Distributions.NormalDistribution.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.Distributions", "qualname": "NormalDistribution.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Distributions.NormalDistribution.cumulative", "modulename": "Fumagalli_Motta_Tarantino_2020.Distributions", "qualname": "NormalDistribution.cumulative", "type": "function", "doc": "<p>Returns the value of the cumulative distribution function.</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>x</strong> (float):\nValue to get the corresponding value of the cumulative distribution function.</li>\n<li><strong>kwargs</strong>: Parameters for the distribution (-> see class documentation)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: Value of the cumulative distribution function.</li>\n</ul>\n", "signature": "(x: float, **kwargs) -> float", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Distributions.NormalDistribution.inverse_cumulative", "modulename": "Fumagalli_Motta_Tarantino_2020.Distributions", "qualname": "NormalDistribution.inverse_cumulative", "type": "function", "doc": "<p>Returns the value of the inverse cumulative distribution function (percent point function).</p>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>q</strong> (float):\nValue to get the corresponding value of the inverse cumulative distribution function.</li>\n<li><strong>kwargs</strong>: Parameters for the distribution (-> see class documentation)</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>float</strong>: Value of the inverse cumulative distribution function.</li>\n</ul>\n", "signature": "(q: float, **kwargs) -> float", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Distributions.UniformDistribution", "modulename": "Fumagalli_Motta_Tarantino_2020.Distributions", "qualname": "UniformDistribution", "type": "class", "doc": "<p>Represents a uniform distribution function ($U_{[loc, loc+scale]}$).</p>\n\n<p>Parameters for the distribution:</p>\n\n<ul>\n<li>loc: start of distribution</li>\n<li>scale: difference added to the start of the beginning of the distribution (-> defining the end of the distribution)</li>\n</ul>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Distributions.UniformDistribution.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.Distributions", "qualname": "UniformDistribution.__init__", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Distributions.UniformDistribution.cumulative", "modulename": "Fumagalli_Motta_Tarantino_2020.Distributions", "qualname": "UniformDistribution.cumulative", "type": "function", "doc": "<p></p>\n", "signature": "(x: float, **kwargs) -> float", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Distributions.UniformDistribution.inverse_cumulative", "modulename": "Fumagalli_Motta_Tarantino_2020.Distributions", "qualname": "UniformDistribution.inverse_cumulative", "type": "function", "doc": "<p></p>\n", "signature": "(q: float, **kwargs) -> float", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Exceptions", "modulename": "Fumagalli_Motta_Tarantino_2020.Exceptions", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Exceptions.MergerPolicyNotAvailable", "modulename": "Fumagalli_Motta_Tarantino_2020.Exceptions", "qualname": "MergerPolicyNotAvailable", "type": "class", "doc": "<p>Method or function hasn't been implemented yet.</p>\n", "bases": "builtins.NotImplementedError"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels.ProCompetitive", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "qualname": "ProCompetitive", "type": "class", "doc": "<p>Add functionality to determine the optimal merger policy for a given set of parameters.</p>\n\n<p>Annotation: As discussed in section 5.1, a policy that is more lenient with respect to early acquisitions is always\ndominated by a strict merger policy. Therefore, only the three remaining policies are discussed.</p>\n", "bases": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels.ProCompetitive.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "qualname": "ProCompetitive.__init__", "type": "function", "doc": "<p>Takes the same arguments as BaseModel.__init__.</p>\n", "signature": "(self, consumer_surplus_without_innovation: float = 0.3, **kwargs)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels.ProCompetitive.is_strict_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "qualname": "ProCompetitive.is_strict_optimal", "type": "function", "doc": "<p>Returns whether the strict merger policy is optimal.</p>\n\n<p>The strict merger is optimal, if the other policies are not optimal.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If the strict merger policy is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels.ProCompetitive.is_intermediate_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "qualname": "ProCompetitive.is_intermediate_optimal", "type": "function", "doc": "<p>Returns whether an intermediate merger policy (late takeover allowed) is optimal.</p>\n\n<p>An intermediate merger policy (late takeovers allowed) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Approving early takeovers followed by shelving is not optimal ($F(\\bar{A}^T) &lt; \\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If an intermediate merger policy (late takeover allowed) is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels.ProCompetitive.is_laissez_faire_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "qualname": "ProCompetitive.is_laissez_faire_optimal", "type": "function", "doc": "<p>Returns whether a laissez-faire policy is optimal.</p>\n\n<p>A laissez-faire policy (that authorises any takeover) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Financial imperfections are severe ($F(\\bar{A}^T)\\ge\\Phi^T(\\cdot)$).</li>\n<li>Approving early takeovers followed by shelving is optimal ($F(\\bar{A}^T)\\ge\\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If a laissez-faire merger policy is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels.ResourceWaste", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "qualname": "ResourceWaste", "type": "class", "doc": "<p>Add functionality to determine the optimal merger policy for a given set of parameters.</p>\n\n<p>Annotation: As discussed in section 5.1, a policy that is more lenient with respect to early acquisitions is always\ndominated by a strict merger policy. Therefore, only the three remaining policies are discussed.</p>\n", "bases": "ProCompetitive"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels.ResourceWaste.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "qualname": "ResourceWaste.__init__", "type": "function", "doc": "<p>Takes the same arguments as BaseModel.__init__.</p>\n", "signature": "(self, consumer_surplus_duopoly=0.41, **kwargs)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels.ResourceWaste.is_strict_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "qualname": "ResourceWaste.is_strict_optimal", "type": "function", "doc": "<p>Returns whether the strict merger policy is optimal.</p>\n\n<p>The strict merger is optimal, if the other policies are not optimal.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If the strict merger policy is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels.ResourceWaste.is_intermediate_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "qualname": "ResourceWaste.is_intermediate_optimal", "type": "function", "doc": "<p>Returns whether an intermediate merger policy (late takeover allowed) is optimal.</p>\n\n<p>An intermediate merger policy (late takeovers allowed) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Approving early takeovers followed by shelving is not optimal ($F(\\bar{A}^T) &lt; \\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If an intermediate merger policy (late takeover allowed) is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels.ResourceWaste.is_laissez_faire_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "qualname": "ResourceWaste.is_laissez_faire_optimal", "type": "function", "doc": "<p>Returns whether a laissez-faire policy is optimal.</p>\n\n<p>A laissez-faire policy (that authorises any takeover) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Financial imperfections are severe ($F(\\bar{A}^T)\\ge\\Phi^T(\\cdot)$).</li>\n<li>Approving early takeovers followed by shelving is optimal ($F(\\bar{A}^T)\\ge\\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If a laissez-faire merger policy is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.ExtensionModels.ResourceWaste.is_financial_imperfection_severe_without_late_takeover", "modulename": "Fumagalli_Motta_Tarantino_2020.ExtensionModels", "qualname": "ResourceWaste.is_financial_imperfection_severe_without_late_takeover", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel", "type": "class", "doc": "<p>There are three players in our game: an Antitrust Authority (AA), which at the beginning of the game decides its\nmerger policy; a monopolist $       {I}$ncumbent; and a $   {S}$tart-up. The start-up owns a \u201cprototype\u201d (or project)\nthat, if developed, can give rise to an innovation: for instance a substitute/higher quality product to the\nincumbent\u2019s existing product, or a more efficient production process. The start-up does not have enough own\nresources to develop the project. It has two options: it can either obtain additional funds from competitive\ncapital markets, or sell out to the incumbent. The incumbent will have to decide whether and when it wants to\nacquire the start-up (and if it does so before product development, it has to decide whether to develop the\nprototype or shelve it), conditional on the AA\u2019s approval of the acquisition. We assume that the takeover\ninvolves a negligible but positive transaction cost. The AA commits at the beginning of the game to a merger\npolicy, in the form of a maximum threshold of \u201charm\u201d, that it is ready to tolerate. Harm from a proposed merger\nconsists of the difference between the expected welfare levels if the merger goes ahead, and in the counterfactual\nwhere it does not take place (derived of course by correctly anticipating the continuation equilibrium of the\ngame). A proposed merger will be prohibited only if the tolerated harm level H is lower than the expected harm\nfrom the merger, if any.</p>\n\n<p>Timing of the game:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Time</th>\n  <th>Action</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>0</td>\n  <td>The AA commits to the standard for merger approval, $\\bar{H}$.</td>\n</tr>\n<tr>\n  <td>1(a)</td>\n  <td>$  {I}$ can make a takeover offer to $     {S}$, which can accept or reject.</td>\n</tr>\n<tr>\n  <td>1(b)</td>\n  <td>The AA approves or blocks the takeover proposal.</td>\n</tr>\n<tr>\n  <td>1(c)</td>\n  <td>The firm ($        {I}$ or $       {S}$) that owns the prototype decides whether to develop or shelve it.</td>\n</tr>\n<tr>\n  <td>1(d)</td>\n  <td>The owner of the prototype engages in financial contracting (if needed). After that, uncertainty about the success or failure of the project resolves.</td>\n</tr>\n<tr>\n  <td>2(a)</td>\n  <td>$  {I}$ can make a take-it-or-leave-it offer to $  {S}$ (if it did not already buy it at t = 1, and if the development of the project was successful).</td>\n</tr>\n<tr>\n  <td>2(b)</td>\n  <td>The AA approves or blocks the takeover proposal.</td>\n</tr>\n<tr>\n  <td>3</td>\n  <td>Active firms sell in the product market, payoffs are realised and contracts are honored.</td>\n</tr>\n</tbody>\n</table>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.__init__", "type": "function", "doc": "<p>Initializes a valid base model according to the assumptions given in the paper.</p>\n\n<p>The following assumptions have to be met:</p>\n\n<table>\n<thead>\n<tr>\n  <th>Condition</th>\n  <th>Remark</th>\n  <th>Page (Assumption)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td>$\\bar{H} \\ge 0$</td>\n  <td>The tolerated level of harm has to be bigger than 0.</td>\n  <td>p.6</td>\n</tr>\n<tr>\n  <td>$p \\in (0,1]$</td>\n  <td>Probability that the prototype is developed successfully depends on the non-contractible effort exerted by the entrepreneur of the firm that owns the project. In case of no effort the project fails for sure, but the entrepreneur obtains a positive private benefit. In case of failure the project yields no profit.</td>\n  <td>p.8</td>\n</tr>\n<tr>\n  <td>$B>0$</td>\n  <td>Private benefit of the entrepreneur in case of failure.</td>\n  <td>p.8</td>\n</tr>\n<tr>\n  <td>$A \\in (0,K)$</td>\n  <td>The startup does not hold sufficient assets at the beginning to cover the costs.</td>\n  <td>p.8</td>\n</tr>\n<tr>\n  <td>$\\pi^m_I>\\pi^d_I$</td>\n  <td>Profit of the incumbent has to be bigger without the innovation than in the duopoly.</td>\n  <td>p.7</td>\n</tr>\n<tr>\n  <td>$\\pi^M_I>\\pi^m_I$</td>\n  <td>Industry profits are higher with a multi-product monopolist than a single product monopolist (otherwise, the incumbent would always shelve).</td>\n  <td>p.7</td>\n</tr>\n<tr>\n  <td>$CS^M \\ge CS^m$</td>\n  <td>Consumer surplus with the innovation has to weakly bigger than without the innovation (consumers like variety).</td>\n  <td>p.7</td>\n</tr>\n<tr>\n  <td>$\\pi^M_I>\\pi^d_I+\\pi^d_S$</td>\n  <td>Industry profits are higher under monopoly than under duopoly. If this assumption did not hold, the takeover would not take place.</td>\n  <td>p.7 (A1)</td>\n</tr>\n<tr>\n  <td>$\\pi^d_S>\\pi^M_I-\\pi^m_I$</td>\n  <td>An incumbent has less incentive to innovate (in a new/better product or a more efficient production process) than a potential entrant because the innovation would cannibalise the incumbent\u2019s current profits. (Corresponds to Arrow's replacement effect)</td>\n  <td>p.7 (A2)</td>\n</tr>\n<tr>\n  <td>$p\\pi^d_S>K$</td>\n  <td>In case of effort it is efficient to develop the prototype, i.e., development has a positive net present value (NPV) for the start-up</td>\n  <td>p.8 (A3)</td>\n</tr>\n<tr>\n  <td>$p(W^M-W^m)&gt;K$</td>\n  <td>The development of the project is not only privately beneficial for the start-up, but also for society as a whole, whether undertaken by the incumbent or the start-up (implies $\\;p(W^d-W^m)&gt;K\\;$).</td>\n  <td>p.8 (A4)</td>\n</tr>\n<tr>\n  <td>$B-K&lt;0$$B-(p\\pi^d_S-K)&gt;0$</td>\n  <td>The first inequality implies that if S shirks the project has negative value; thus, no financial contract could be signed unless the startup makes effort. The second implies that the start-up may be financially constrained, that is, it may hold insufficient assets to fund the development of the prototype even though the project has a positive NPV.</td>\n  <td>p.8 (A5)</td>\n</tr>\n</tbody>\n</table>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>development_costs</strong> (float):\n($K$) Fixed costs to invest for development.</li>\n<li><strong>startup_assets</strong> (float):\n($A$) Assets of the startup at the beginning.</li>\n<li><strong>success_probability</strong> (float):\n($p$) Probability of success in case of effort (otherwise the projects fails for sure).</li>\n<li><strong>development_success</strong> (bool):\nDecides whether an attempted development will be successful (true $\\rightarrow$ attempted development succeeds).</li>\n<li><strong>private_benefit</strong> (float):\n($B$) Private benefit of the entrepreneur in case of failure.</li>\n<li><strong>consumer_surplus_without_innovation</strong> (float):\n($CS^m$) Consumer surplus for the case that the innovation is not introduced by the incumbent into the market.</li>\n<li><strong>incumbent_profit_without_innovation</strong> (float):\n($\\pi^m_I$) Profit of the monopolist with a single product (without innovation).</li>\n<li><strong>consumer_surplus_duopoly</strong> (float):\n($CS^d$) Consumer surplus for the case that the innovation is introduced into the market and a duopoly exists.</li>\n<li><strong>incumbent_profit_duopoly</strong> (float):\n($\\pi^d_I$) Profit of the incumbent in the case of a duopoly.</li>\n<li><strong>startup_profit_duopoly</strong> (float):\n($\\pi^d_S$) Profit of the startup in the case of a duopoly.</li>\n<li><strong>consumer_surplus_with_innovation</strong> (float):\n($CS^M$) Consumer surplus for the case that the innovation is introduced by the incumbent into the market.</li>\n<li><strong>incumbent_profit_with_innovation</strong> (float):\n($\\pi^M_I$) Profit of the monopolist with multiple products (with innovation).</li>\n</ul>\n", "signature": "(\n    self,\n    merger_policy: Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies = <MergerPolicies.Strict: 'Strict'>,\n    development_costs: float = 0.1,\n    startup_assets: float = 0.05,\n    success_probability: float = 0.7,\n    development_success: bool = True,\n    private_benefit: float = 0.05,\n    consumer_surplus_without_innovation: float = 0.2,\n    incumbent_profit_without_innovation: float = 0.4,\n    consumer_surplus_duopoly: float = 0.5,\n    incumbent_profit_duopoly: float = 0.2,\n    startup_profit_duopoly: float = 0.2,\n    consumer_surplus_with_innovation: float = 0.3,\n    incumbent_profit_with_innovation: float = 0.5,\n    asset_distribution: Union[Fumagalli_Motta_Tarantino_2020.Distributions.NormalDistribution, Fumagalli_Motta_Tarantino_2020.Distributions.UniformDistribution] = <class 'Fumagalli_Motta_Tarantino_2020.Distributions.NormalDistribution'>,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.development_costs", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.development_costs", "type": "variable", "doc": "<p>($K$) Fixed costs to invest for development.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.startup_assets", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.startup_assets", "type": "variable", "doc": "<p>($A$) Assets of the startup at the beginning.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.success_probability", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.success_probability", "type": "variable", "doc": "<p>($p$) Probability of success in case of effort (otherwise the projects fails for sure).</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.development_success", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.development_success", "type": "variable", "doc": "<p>Decides whether an attempted development will be successful.</p>\n\n<p>If true, every attempted development will be successful.</p>\n", "annotation": ": bool"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.private_benefit", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.private_benefit", "type": "variable", "doc": "<p>($B$) Private benefit of the entrepreneur in case of failure.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.incumbent_profit_with_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.incumbent_profit_with_innovation", "type": "variable", "doc": "<p>($\\pi^M_I$) Profit of the monopolist with multiple products (with innovation).</p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.cs_with_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.cs_with_innovation", "type": "variable", "doc": "<p>($CS^M$) Consumer surplus for the case that the innovation is introduced by the incumbent into the market.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.w_with_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.w_with_innovation", "type": "variable", "doc": "<p>($W^M$) Total welfare for the case that the innovation is introduced by the incumbent into the market.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.incumbent_profit_without_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.incumbent_profit_without_innovation", "type": "variable", "doc": "<p>($\\pi^m_I$) Profit of the monopolist with a single product (without innovation).</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.cs_without_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.cs_without_innovation", "type": "variable", "doc": "<p>($CS^m$) Consumer surplus for the case that the innovation is not introduced by the incumbent into the market.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.w_without_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.w_without_innovation", "type": "variable", "doc": "<p>($W^m$) Total welfare for the case that the innovation is not introduced by the incumbent into the market.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.startup_profit_duopoly", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.startup_profit_duopoly", "type": "variable", "doc": "<p>($\\pi^d_S$) Profit of the startup in the case of a duopoly.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.incumbent_profit_duopoly", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.incumbent_profit_duopoly", "type": "variable", "doc": "<p>($\\pi^d_I$) Profit of the incumbent in the case of a duopoly.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.cs_duopoly", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.cs_duopoly", "type": "variable", "doc": "<p>($CS^d$) Consumer surplus for the case that the innovation is introduced into the market and a duopoly exists.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.BaseModel.w_duopoly", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "BaseModel.w_duopoly", "type": "variable", "doc": "<p>($W^d$) Total welfare for the case that the innovation is introduced into the market and a duopoly exists.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy", "type": "class", "doc": "<p>In this class all merger policies and their respective outcomes are calculated.</p>\n\n<p>The available merger policies are documented in Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies.</p>\n", "bases": "BaseModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.__init__", "type": "function", "doc": "<p>Takes the same arguments as BaseModel.__init__.</p>\n", "signature": "(self, *args, **kwargs)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.merger_policy", "type": "variable", "doc": "<p>Returns the merger policy used to determine the outcome, given by the thresholds for tolerated harm.</p>\n\n<p>The levels of tolerated harm are defined in A.4 (p.36ff.). See Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies\nfor the available merger policies.</p>\n", "annotation": ": Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.tolerated_harm", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.tolerated_harm", "type": "variable", "doc": "<p>($\\bar{H}$) The AA commits at the beginning of the game to a merger policy. The tolerated harm is the maximal loss of welfare the AA is ready to accept.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.asset_threshold", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.asset_threshold", "type": "variable", "doc": "<p>Threshold level $\\bar{A} = B - (\\pi^d_S - K)$</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.asset_threshold_cdf", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.asset_threshold_cdf", "type": "variable", "doc": "<p>Returns the value of the continuous distribution function for the asset threshold.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.asset_threshold_late_takeover", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.asset_threshold_late_takeover", "type": "variable", "doc": "<p>The prospect that the start-up will be acquired at $t = 2$ alleviates financial constraints: there exists a\nthreshold level $\\bar{A}^T = B - (\\pi_I^M - K)$</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.asset_threshold_late_takeover_cdf", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.asset_threshold_late_takeover_cdf", "type": "variable", "doc": "<p>Returns the value of the continuous distribution function for the asset threshold under laissez-faire.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.startup_assets", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.startup_assets", "type": "variable", "doc": "<p>($A$) Assets of the startup at the beginning.</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.early_bidding_type", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.early_bidding_type", "type": "variable", "doc": "<p>Returns the bidding attempt of the incumbent at $t = 1$.</p>\n\n<p>See Fumagalli_Motta_Tarantino_2020.Types.Takeover for the available options.</p>\n", "annotation": ": Fumagalli_Motta_Tarantino_2020.Types.Takeover"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.late_bidding_type", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.late_bidding_type", "type": "variable", "doc": "<p>Returns the bidding attempt of the incumbent at $t = 2$.</p>\n\n<p>See Fumagalli_Motta_Tarantino_2020.Types.Takeover for the available options.</p>\n", "annotation": ": Fumagalli_Motta_Tarantino_2020.Types.Takeover"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.is_early_takeover", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.is_early_takeover", "type": "variable", "doc": "<p>Returns whether the start-up is acquired by the incumbent at $t=1$.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If the start-up is acquired by the incumbent at $t=1$.</li>\n</ul>\n", "annotation": ": bool"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.is_late_takeover", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.is_late_takeover", "type": "variable", "doc": "<p>Returns whether the start-up is acquired by the incumbent at $t=2$.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If the start-up is acquired by the incumbent at $t=2$.</li>\n</ul>\n", "annotation": ": bool"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.is_owner_investing", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.is_owner_investing", "type": "variable", "doc": "<p>A start-up that expects external investors to deny financing will not undertake the investment. Conversely, the incumbent\nhas the financial ability to invest, but it does not always have the incentive to do so. Indeed, the innovation\nincreases the incumbent\u2019s profits less than the (unconstrained) start-up\u2019s. (This result follows directly from\nthe Arrow\u2019s replacement effect) The increase in the incumbent\u2019s profits may not be large enough to cover the investment\ncost. When this is the case, the incumbent will shelve the project and the acquisition turns out to be a killer acquisition.</p>\n\n<p>Investment decision under the strict merger policy:</p>\n\n<ul>\n<li>An unconstrained start-up always invests in the development of the prototype.</li>\n<li>The incumbent invests if (and only if): $p*(\\pi^M_I-\\pi^m_I) \\ge K$</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If the owner of the innovation at $t=1$ invests in the project, instead of shelving.</li>\n</ul>\n", "annotation": ": bool"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.is_development_successful", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.is_development_successful", "type": "variable", "doc": "<p>Returns whether the development was successful or not.</p>\n\n<p>The following two conditions have to be satisfied:</p>\n\n<ul>\n<li>The owner of the product at $t=1$ has to invest in the development</li>\n<li>The development success variable has to be set to True (attempted development always successful).</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If both conditions are met.</li>\n</ul>\n", "annotation": ": bool"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.is_startup_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.is_startup_credit_rationed", "type": "variable", "doc": "<p>If no takeover took place at t = 1(b), a start-up that decided to develop the project searches for funding at $t = 1(d)$.</p>\n\n<p>Strict and Intermediate (late takeover prohibited):</p>\n\n<ul>\n<li>$A &lt; \\bar{A}$, the start-up is credit-rationed and cannot invest.</li>\n<li>$A \\ge \\bar{A}$, the start-up obtains external funding.</li>\n</ul>\n\n<p>Laissez-Faire and Intermediate (late takeover allowed): $$</p>\n\n<ul>\n<li>$A &lt; \\bar{A}^T$, the start-up is credit-rationed and cannot invest.</li>\n<li>$A \\ge \\bar{A}^T$, the start-up obtains external funding.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If the start-up is credit rationed.</li>\n</ul>\n", "annotation": ": bool"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.asset_distribution_threshold_welfare", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.asset_distribution_threshold_welfare", "type": "variable", "doc": "<p>Threshold defined in Lemma 3 :$\\;\\Gamma(\\cdot)=\\frac{p(W^d-W^M)}{p(W^d-W^m)-K}$</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.asset_distribution_threshold_profitable_without_late_takeover", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.asset_distribution_threshold_profitable_without_late_takeover", "type": "variable", "doc": "<p>Threshold defined in Condition 3 :$\\;\\Phi(\\cdot)=\\frac{p(\\pi^M_I-\\pi^d_I-\\pi^d_S)}{p(\\pi^M_I-\\pi^d_I)-K}$</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.asset_distribution_threshold_with_late_takeover", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.asset_distribution_threshold_with_late_takeover", "type": "variable", "doc": "<p>Threshold defined in Condition 4 :$\\;\\Phi^T(\\cdot)=\\frac{p(\\pi^m_I-\\pi^M_I)+K}{p(\\pi^m_I+\\pi^d_S-\\pi^M_I)}$</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.asset_distribution_threshold_unprofitable_without_late_takeover", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.asset_distribution_threshold_unprofitable_without_late_takeover", "type": "variable", "doc": "<p>Threshold defined in A-3 :$\\;\\Phi^{\\prime}(\\cdot)=\\frac{p(\\pi^m_I-\\pi^d_I-\\pi^d_S)+K}{p(\\pi^m_I+\\pi^d_I)}$</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.is_incumbent_expected_to_shelve", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.is_incumbent_expected_to_shelve", "type": "function", "doc": "<p>Returns whether the incumbent is expected to shelve, whenever it acquires the entrant (Condition 1).</p>\n\n<ul>\n<li><p>True (expected to shelve): $p*(\\pi^M_I-\\pi^m_I) &lt; K$</p></li>\n<li><p>False (not expected to shelve): $p*(\\pi^M_I-\\pi^m_I) \\ge K$</p></li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.incumbent_expected_additional_profit_from_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.incumbent_expected_additional_profit_from_innovation", "type": "function", "doc": "<p>Returns the additional expected profit for the incumbent, if it does not shelve the product after an acquisition.</p>\n\n<p>$ Expected \\; additional \\; profit = p*(\\pi^M_I-\\pi^m_I)-K$</p>\n", "signature": "(self) -> float", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.summary", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.summary", "type": "function", "doc": "<p>Returns the calculated outcome of the model with the defined parameters.</p>\n\n<p>The resulting dictionary contains the following information (and keys):</p>\n\n<ul>\n<li>'set_policy' : Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies -> Defines the chosen merger policy based on the tolerated level of harm.</li>\n<li>'credit_rationed' : True, if the start-up is credit rationed.</li>\n<li>'early_bidding_type' : Fumagalli_Motta_Tarantino_2020.Types.Takeover -> Defines the bidding type of the incumbent at t=1.</li>\n<li>'late_bidding_type' : 'Fumagalli_Motta_Tarantino_2020.Types.Takeover -> Defines the bidding type of the incumbent at t=2.</li>\n<li>'development_attempt' : True, if the owner (start-up or incumbent after a takeover) tries to develop the product.</li>\n<li>'development_outcome' : True, if the product is developed successfully.</li>\n<li>'early_takeover' : True, if a takeover takes place at $t=1$.</li>\n<li>'late_takeover' : True, if a takeover takes place at $t=2$.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Types.Summary</strong>: Containing the result of the model with the defined parameters.</li>\n</ul>\n", "signature": "(self) -> Fumagalli_Motta_Tarantino_2020.Types.Summary", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.is_killer_acquisition", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "MergerPolicy.is_killer_acquisition", "type": "function", "doc": "<p>Returns whether a killer acquisition occurred in the model.</p>\n\n<p>For a killer acquisition to take place the following condition have to satisfied:</p>\n\n<ul>\n<li>An early takeover takes place</li>\n<li>The incumbent does not develop the product</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: if a killer acquisition occurred in the model.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "OptimalMergerPolicy", "type": "class", "doc": "<p>Add functionality to determine the optimal merger policy for a given set of parameters.</p>\n\n<p>Annotation: As discussed in section 5.1, a policy that is more lenient with respect to early acquisitions is always\ndominated by a strict merger policy. Therefore, only the three remaining policies are discussed.</p>\n", "bases": "MergerPolicy"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "OptimalMergerPolicy.__init__", "type": "function", "doc": "<p>Takes the same arguments as BaseModel.__init__.</p>\n", "signature": "(self, *args, **kwargs)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.get_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "OptimalMergerPolicy.get_optimal_merger_policy", "type": "function", "doc": "<p>A strict merger policy is always optimal when the incumbent is expected to invest. When the incumbent is expected\nto shelve, a more lenient policy (that either authorises any type of takeover, or that blocks early takeovers when\nthe incumbent makes a pooling bid and plans to shelve, and authorises late takeovers) may be optimal, but under the\ncumulative conditions indicated in proposition 4.</p>\n\n<p>See: OptimalMergerPolicy.is_laissez_faire_optimal, OptimalMergerPolicy.is_intermediate_optimal and OptimalMergerPolicy.is_strict_optimal</p>\n", "signature": "(self) -> Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.is_laissez_faire_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "OptimalMergerPolicy.is_laissez_faire_optimal", "type": "function", "doc": "<p>Returns whether a laissez-faire policy is optimal.</p>\n\n<p>A laissez-faire policy (that authorises any takeover) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Financial imperfections are severe ($F(\\bar{A}^T)\\ge\\Phi^T(\\cdot)$).</li>\n<li>Approving early takeovers followed by shelving is optimal ($F(\\bar{A}^T)\\ge\\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If a laissez-faire merger policy is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.is_intermediate_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "OptimalMergerPolicy.is_intermediate_optimal", "type": "function", "doc": "<p>Returns whether an intermediate merger policy (late takeover allowed) is optimal.</p>\n\n<p>An intermediate merger policy (late takeovers allowed) is optimal, if:</p>\n\n<ol>\n<li>Incumbent is expected to shelve ($p(\\pi^M_I-\\pi^m_I) &lt; K$).</li>\n<li>Approving early takeovers followed by shelving is not optimal ($F(\\bar{A}^T) &lt; \\Lambda(\\cdot)$).</li>\n<li>Detrimental effect of less intense product market competition is dominated by the benefit of making it more\nlikely that the innovation is commercialised (Condition 6 not satisfied).</li>\n</ol>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If an intermediate merger policy (late takeover allowed) is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.is_strict_optimal", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "OptimalMergerPolicy.is_strict_optimal", "type": "function", "doc": "<p>Returns whether the strict merger policy is optimal.</p>\n\n<p>The strict merger is optimal, if the other policies are not optimal.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If the strict merger policy is optimal.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.is_competition_effect_dominating", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "OptimalMergerPolicy.is_competition_effect_dominating", "type": "function", "doc": "<p>Condition 6: $\\frac{p(W^d-W^m)-K}{p(W^M-W^m)-K} \\ge \\frac{1-F(\\bar{A}^T)}{1-F(\\bar{A})}$</p>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.is_financial_imperfection_severe", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "OptimalMergerPolicy.is_financial_imperfection_severe", "type": "function", "doc": "<p>Returns whether financial imperfections are severe.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If the financial imperfections are severe.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.is_intermediate_policy_feasible", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "OptimalMergerPolicy.is_intermediate_policy_feasible", "type": "function", "doc": "<p>If the harm to welfare caused by an early takeover is lower than the one, caused by a late takeover, then also\nearly takeovers must be approved, even in the case of a pooling offer followed by shelving. Such a scenario occurs\nif (and only if): $F(\\bar{A}^T)\\ge\\Lambda(\\cdot)$</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>True</strong>: If the above-mentioned condition is met.</li>\n</ul>\n", "signature": "(self) -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.asset_distribution_threshold_shelving_approved", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "OptimalMergerPolicy.asset_distribution_threshold_shelving_approved", "type": "variable", "doc": "<p>Threshold defined in Condition 5 :$\\;\\Lambda(\\cdot)=\\frac{p(W^M-W^m)-K-(W^d-W^M)}{p(W^M-W^m)-K}$</p>\n", "annotation": ": float"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.summary", "modulename": "Fumagalli_Motta_Tarantino_2020.Models", "qualname": "OptimalMergerPolicy.summary", "type": "function", "doc": "<p>Returns the calculated outcome of the model with the defined parameters.</p>\n\n<p>Additional information compared to Fumagalli_Motta_Tarantino_2020.Models.MergerPolicyModel.summary:</p>\n\n<ul>\n<li>'optimal_policy' : Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies -> Defines the welfare maximizing merger policy.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Types.Summary</strong>: Containing the result of the model with the defined parameters.</li>\n</ul>\n", "signature": "(self) -> Fumagalli_Motta_Tarantino_2020.Types.OptimalMergerPolicySummary", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Project", "modulename": "Fumagalli_Motta_Tarantino_2020.Project", "type": "module", "doc": "<h2 id=\"project-structure\">Project Structure</h2>\n\n<p>Build the folder structure with the following command (or execute <code>assets/Structure/tree.sh</code>):</p>\n\n<div class=\"pdoc-code codehilite\"><pre><span></span><code>git config --global alias.tree <span class=\"s1\">&#39;! git ls-tree --full-name --name-only -t -r HEAD | sed -e &quot;s/[^-][^\\/]*\\//   |/g&quot; -e &quot;s/|\\([^ ]\\)/|-- \\1/&quot;&#39;</span>\ngit tree\n</code></pre></div>\n\n<p>This command just works for Git - repositories and not for folder structures in general.</p>\n\n<p>This is the annotated folder structure:</p>\n\n<pre><code>.github\n   |-- workflows\n   |   |-- Black.yml  # checks the code style on errors\n   |   |-- CodeCov.yml  # pushes the newest CI results to codecov.io\n   |   |-- PyPI.yml  # pushes releases automatically on PyPI\n   |   |-- codeql-analysis.yml  # checks for weaknesses in code\nFumagalli_Motta_Tarantino_2020  # package as published on PyPI\n   |-- AdditionalModels.py  # MicroFoundationModel and PerfectInformationModel\n   |-- Models.py  # BaseModel, MergerPolicy and OptimalMergerPolicy\n   |-- Types.py  # Additional enums and dataclasses\n   |-- Utilities.py  # useful classes for support in models\n   |-- Visualize.py  # visualizations for the models\n   |-- __init__.py\n   |-- tests  # includes tests for the models and visualizations\n   |   |-- MockModels.py\n   |   |-- TestCases.md\n   |   |-- Test_AdditionalModels.py\n   |   |-- Test_Model.py\n   |   |-- Test_Distributions.py\n   |   |-- Test_Visualize.py\n   |   |-- __init__.py\nNotebooks\n   |-- README.md  # introduction to the provided notebooks\n   |-- __init__.py\n   |-- test.ipynb\nassets  # additional ressources regarding the code\n   |-- Strucutre  # contains informations about the project and code structure\n   |   |-- class_diagram.drawio  # UML class diagram\n   |   |-- tree.sh  # generated this tree of the project structure\n   |-- code style  # bash scripts for automatic check and enforcement of code style\n   |   |-- check_black.sh\n   |   |-- run_black.sh\n   |-- visual  # contains graphics such as images and sketches\n   |   |-- logo.svg\ndocs  # contains the files for the documentation page (automatically generated with pdoc)\n   |-- build.sh  # bash script to execute build of documentation\nCITATION.cff  # for citation of the repository\nFumagalli et al (2020) - Shelving or developing  # Original paper\nREADME.md  # introduction to the package\nLICENSE\nrequirements.txt  # needed dependcies for the package\nsetup.py  # setup script for publication on PyPI\n</code></pre>\n\n<h2 id=\"class-diagram\">Class diagram</h2>\n\n<p><img src=\"../visual/class_diagram.svg\" alt=\"Class diagram\" /> (If the class diagram is not shown, follow this <a href=\"https://github.com/manuelbieri/Fumagalli_2020/blob/master/assets/visual/class_diagram.svg\">link</a>)</p>\n\n<h2 id=\"code-style\">Code style</h2>\n\n<p>As default code style <a href=\"https://black.readthedocs.io/en/stable/the_black_code_style/current_style.html\">Black</a> is used and\nautomatically checked and enforced by GitHub - workflows.</p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Project.docs", "modulename": "Fumagalli_Motta_Tarantino_2020.Project", "qualname": "docs", "type": "function", "doc": "<p>Opens the API documentation in the browser.</p>\n", "signature": "() -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Project.repo", "modulename": "Fumagalli_Motta_Tarantino_2020.Project", "qualname": "repo", "type": "function", "doc": "<p>Opens the Git - repository in the browser.</p>\n", "signature": "() -> bool", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "MergerPolicies", "type": "class", "doc": "<p>Defines the available merger policies in the models.</p>\n", "bases": "enum.Enum"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies.Strict", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "MergerPolicies.Strict", "type": "variable", "doc": "<p>The AA authorises only takeovers that, at the moment in which they are reviewed, are expected to increase total welfare.</p>\n", "default_value": " = <MergerPolicies.Strict: 'Strict'>"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies.Intermediate_late_takeover_prohibited", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "MergerPolicies.Intermediate_late_takeover_prohibited", "type": "variable", "doc": "<p>The AA blocks late takeovers, but is more lenient with early takeovers.</p>\n", "default_value": " = <MergerPolicies.Intermediate_late_takeover_prohibited: 'Intermediate (late takeover prohibited)'>"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies.Intermediate_late_takeover_allowed", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "MergerPolicies.Intermediate_late_takeover_allowed", "type": "variable", "doc": "<p>The AA authorises late takeovers, but is stricter with early takeovers.</p>\n", "default_value": " = <MergerPolicies.Intermediate_late_takeover_allowed: 'Intermediate (late takeover allowed)'>"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies.Laissez_faire", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "MergerPolicies.Laissez_faire", "type": "variable", "doc": "<p>The intervention threshold of the AA is so high that any acquisition would be allowed.</p>\n", "default_value": " = <MergerPolicies.Laissez_faire: 'Laissez-faire'>"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies.abbreviation", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "MergerPolicies.abbreviation", "type": "function", "doc": "<p>Generates a string containing the abbreviation of the current merger policy.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Abbreviation of the current merger policy.</li>\n</ul>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies.legend", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "MergerPolicies.legend", "type": "function", "doc": "<p>Generates a string containing the legend of the possible merger policies.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Containing the legend for the merger policies.</li>\n</ul>\n", "signature": "() -> str", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.Takeover", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "Takeover", "type": "class", "doc": "<p>Defines the available options for a takeover of the start-up by the incumbent.</p>\n", "bases": "enum.Enum"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.Takeover.No", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "Takeover.No", "type": "variable", "doc": "<p>The incumbent does not bid for the start-up.</p>\n", "default_value": " = <Takeover.No: 'No bid'>"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.Takeover.Separating", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "Takeover.Separating", "type": "variable", "doc": "<p>The incumbent offers a low takeover price targeting only the credit-rationed start-ups.</p>\n", "default_value": " = <Takeover.Separating: 'Separating bid'>"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.Takeover.Pooling", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "Takeover.Pooling", "type": "variable", "doc": "<p>The incumbent offers a high takeover price such that a start-up would always accept, irrespective of the amount of own assets.</p>\n", "default_value": " = <Takeover.Pooling: 'Pooling bid'>"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.Takeover.abbreviation", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "Takeover.abbreviation", "type": "function", "doc": "<p>Generates a string containing the abbreviation of the current takeover option.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Abbreviation of the current takeover option.</li>\n</ul>\n", "signature": "(self) -> str", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.Takeover.legend", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "Takeover.legend", "type": "function", "doc": "<p>Generates a string containing the legend of the possible takeover options.</p>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>str</strong>: Containing the legend for the takeover options.</li>\n</ul>\n", "signature": "() -> str", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.ThresholdItem", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "ThresholdItem", "type": "class", "doc": "<p>Threshold item containing the name (string representation) and the value (threshold express in float value).</p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.ThresholdItem.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "ThresholdItem.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(self, name: str, value: float, include: bool = False)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.ThresholdItem.include", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "ThresholdItem.include", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.Summary", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "Summary", "type": "class", "doc": "<p>Summary of Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy.</p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.Summary.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "Summary.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    set_policy: Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies,\n    credit_rationed: bool,\n    early_bidding_type: Fumagalli_Motta_Tarantino_2020.Types.Takeover,\n    late_bidding_type: Fumagalli_Motta_Tarantino_2020.Types.Takeover,\n    development_attempt: bool,\n    development_outcome: bool,\n    early_takeover: bool,\n    late_takeover: bool\n)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.OptimalMergerPolicySummary", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "OptimalMergerPolicySummary", "type": "class", "doc": "<p>Summary of Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.</p>\n", "bases": "Summary"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Types.OptimalMergerPolicySummary.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.Types", "qualname": "OptimalMergerPolicySummary.__init__", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    set_policy: Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies,\n    credit_rationed: bool,\n    early_bidding_type: Fumagalli_Motta_Tarantino_2020.Types.Takeover,\n    late_bidding_type: Fumagalli_Motta_Tarantino_2020.Types.Takeover,\n    development_attempt: bool,\n    development_outcome: bool,\n    early_takeover: bool,\n    late_takeover: bool,\n    optimal_policy: Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies\n)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.IVisualize", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "IVisualize", "type": "class", "doc": "<p>Interface for all visualization classes containing useful methods.</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This module is compatible with python versions starting from 3.9, due to introduction of PEP 585. Therefore, the compatibility\nwith mybinder.org is not guaranteed (uses at the moment python 3.7).</p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.IVisualize.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "IVisualize.__init__", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy):\nModel to plot the outcomes from a range of assets.</li>\n</ul>\n", "signature": "(\n    self,\n    model: Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy,\n    ax: Optional[matplotlib.axes._axes.Axes] = None,\n    default_style=True,\n    dark_mode=False,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.IVisualize.colors", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "IVisualize.colors", "type": "variable", "doc": "<p>Standard colors used in visualizations.</p>\n", "annotation": ": list[str]", "default_value": " = ['indianred', 'salmon', 'khaki', 'greenyellow', 'limegreen', 'turquoise', 'powderblue', 'lavender', 'thistle', 'lavenderblush', 'pink']"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.IVisualize.fontsize", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "IVisualize.fontsize", "type": "variable", "doc": "<p>Default font size</p>\n", "default_value": " = 'x-small'"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.IVisualize.set_model", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "IVisualize.set_model", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    model: Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy\n) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.IVisualize.plot", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "IVisualize.plot", "type": "function", "doc": "<p>Plots the visual representation for the object.</p>\n\n<h6 id=\"example\">Example</h6>\n\n<pre><code>model = Models.OptimalMergerPolicy()\nvisualizer = MergerPoliciesAssetRange(m)\nfig, ax = visualizer.plot()\n# use the figure and axes as you wish, but for example:\nfig.show()\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kwargs</strong>: Options for the plots for further customization.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Figure</strong>: Containing the axes with the plots (use Figure.show() to display).</li>\n<li><strong>Axes</strong>: Containing the plots (arrange custom summary).</li>\n</ul>\n", "signature": "(\n    self,\n    **kwargs\n) -> (<class 'matplotlib.figure.Figure'>, <class 'matplotlib.axes._axes.Axes'>)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.IVisualize.show", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "IVisualize.show", "type": "function", "doc": "<p>Shows the visual representation for the object.</p>\n\n<h6 id=\"example\">Example</h6>\n\n<pre><code>model = Models.OptimalMergerPolicy()\nvisualizer = MergerPoliciesAssetRange(m)\nvisualizer.show()\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kwargs</strong>: Same options as Fumagalli_Motta_Tarantino_2020.Visualize.IVisualize.plot.</li>\n</ul>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.Timeline", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "Timeline", "type": "class", "doc": "<p>Visualizes the timeline of events for a specific model.</p>\n", "bases": "IVisualize"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.Timeline.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "Timeline.__init__", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy):\nModel to plot the outcomes from a range of assets.</li>\n</ul>\n", "signature": "(\n    self,\n    model: Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.Timeline.plot", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "Timeline.plot", "type": "function", "doc": "<p>Plots the visual representation for the object.</p>\n\n<h6 id=\"example\">Example</h6>\n\n<pre><code>model = Models.OptimalMergerPolicy()\nvisualizer = MergerPoliciesAssetRange(m)\nfig, ax = visualizer.plot()\n# use the figure and axes as you wish, but for example:\nfig.show()\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kwargs</strong>: Options for the plots for further customization.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Figure</strong>: Containing the axes with the plots (use Figure.show() to display).</li>\n<li><strong>Axes</strong>: Containing the plots (arrange custom summary).</li>\n</ul>\n", "signature": "(\n    self,\n    **kwargs\n) -> (<class 'matplotlib.figure.Figure'>, <class 'matplotlib.axes._axes.Axes'>)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.Payoffs", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "Payoffs", "type": "class", "doc": "<p>Interface for all visualization classes containing useful methods.</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This module is compatible with python versions starting from 3.9, due to introduction of PEP 585. Therefore, the compatibility\nwith mybinder.org is not guaranteed (uses at the moment python 3.7).</p>\n", "bases": "IVisualize"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.Visualize.Payoffs.plot", "modulename": "Fumagalli_Motta_Tarantino_2020.Visualize", "qualname": "Payoffs.plot", "type": "function", "doc": "<p>Plots the visual representation for the object.</p>\n\n<h6 id=\"example\">Example</h6>\n\n<pre><code>model = Models.OptimalMergerPolicy()\nvisualizer = MergerPoliciesAssetRange(m)\nfig, ax = visualizer.plot()\n# use the figure and axes as you wish, but for example:\nfig.show()\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kwargs</strong>: Options for the plots for further customization.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Figure</strong>: Containing the axes with the plots (use Figure.show() to display).</li>\n<li><strong>Axes</strong>: Containing the plots (arrange custom summary).</li>\n</ul>\n", "signature": "(\n    self,\n    **kwargs\n) -> (<class 'matplotlib.figure.Figure'>, <class 'matplotlib.axes._axes.Axes'>)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.AssetRange", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "AssetRange", "type": "class", "doc": "<p>Visualizes the outcomes over an assets range for a specific model.</p>\n", "bases": "Fumagalli_Motta_Tarantino_2020.Visualize.IVisualize"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.AssetRange.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "AssetRange.__init__", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy):\nModel to plot the outcomes from a range of assets.</li>\n</ul>\n", "signature": "(\n    self,\n    model: Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.AssetRange.colors", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "AssetRange.colors", "type": "variable", "doc": "<p>Standard colors used in visualizations.</p>\n", "annotation": ": dict[str, str]", "default_value": " = ['indianred', 'salmon', 'khaki', 'greenyellow', 'limegreen', 'turquoise', 'powderblue', 'lavender', 'thistle', 'lavenderblush', 'pink']"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.AssetRange.set_model", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "AssetRange.set_model", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    model: Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy\n) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.AssetRange.plot", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "AssetRange.plot", "type": "function", "doc": "<p>Plots the visual representation for the object.</p>\n\n<h6 id=\"example\">Example</h6>\n\n<pre><code>model = Models.OptimalMergerPolicy()\nvisualizer = MergerPoliciesAssetRange(m)\nfig, ax = visualizer.plot()\n# use the figure and axes as you wish, but for example:\nfig.show()\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kwargs</strong>: Options for the plots for further customization.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Figure</strong>: Containing the axes with the plots (use Figure.show() to display).</li>\n<li><strong>Axes</strong>: Containing the plots (arrange custom summary).</li>\n</ul>\n", "signature": "(\n    self,\n    **kwargs\n) -> (<class 'matplotlib.figure.Figure'>, <class 'matplotlib.axes._axes.Axes'>)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.MergerPoliciesAssetRange", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "MergerPoliciesAssetRange", "type": "class", "doc": "<p>Visualizes the outcomes over an assets range for a specific model.</p>\n", "bases": "AssetRange"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.MergerPoliciesAssetRange.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "MergerPoliciesAssetRange.__init__", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy):\nModel to plot the outcomes from a range of assets.</li>\n</ul>\n", "signature": "(\n    self,\n    model: Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.MergerPoliciesAssetRangePerfectInformation", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "MergerPoliciesAssetRangePerfectInformation", "type": "class", "doc": "<p>Visualizes the outcomes over an assets range for a specific model.</p>\n", "bases": "MergerPoliciesAssetRange"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.MergerPoliciesAssetRangePerfectInformation.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "MergerPoliciesAssetRangePerfectInformation.__init__", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy):\nModel to plot the outcomes from a range of assets.</li>\n</ul>\n", "signature": "(\n    self,\n    model: Fumagalli_Motta_Tarantino_2020.AdditionalModels.PerfectInformation,\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.MergerPoliciesAssetRangePerfectInformation.plot", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "MergerPoliciesAssetRangePerfectInformation.plot", "type": "function", "doc": "<p>Plots the visual representation for the object.</p>\n\n<h6 id=\"example\">Example</h6>\n\n<pre><code>model = Models.OptimalMergerPolicy()\nvisualizer = MergerPoliciesAssetRange(m)\nfig, ax = visualizer.plot()\n# use the figure and axes as you wish, but for example:\nfig.show()\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kwargs</strong>: Options for the plots for further customization.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Figure</strong>: Containing the axes with the plots (use Figure.show() to display).</li>\n<li><strong>Axes</strong>: Containing the plots (arrange custom summary).</li>\n</ul>\n", "signature": "(\n    self,\n    **kwargs\n) -> (<class 'matplotlib.figure.Figure'>, <class 'matplotlib.axes._axes.Axes'>)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.Overview", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "Overview", "type": "class", "doc": "<p>Interface for all visualization classes containing useful methods.</p>\n\n<h6 id=\"notes\">Notes</h6>\n\n<p>This module is compatible with python versions starting from 3.9, due to introduction of PEP 585. Therefore, the compatibility\nwith mybinder.org is not guaranteed (uses at the moment python 3.7).</p>\n", "bases": "Fumagalli_Motta_Tarantino_2020.Visualize.IVisualize"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.Overview.__init__", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "Overview.__init__", "type": "function", "doc": "<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>model</strong> (Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy):\nModel to plot the outcomes from a range of assets.</li>\n</ul>\n", "signature": "(\n    self,\n    model: Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy,\n    figsize=(14, 10),\n    **kwargs\n)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges.Overview.plot", "modulename": "Fumagalli_Motta_Tarantino_2020.VisualizeRanges", "qualname": "Overview.plot", "type": "function", "doc": "<p>Plots the visual representation for the object.</p>\n\n<h6 id=\"example\">Example</h6>\n\n<pre><code>model = Models.OptimalMergerPolicy()\nvisualizer = MergerPoliciesAssetRange(m)\nfig, ax = visualizer.plot()\n# use the figure and axes as you wish, but for example:\nfig.show()\n</code></pre>\n\n<h6 id=\"parameters\">Parameters</h6>\n\n<ul>\n<li><strong>kwargs</strong>: Options for the plots for further customization.</li>\n</ul>\n\n<h6 id=\"returns\">Returns</h6>\n\n<ul>\n<li><strong>Figure</strong>: Containing the axes with the plots (use Figure.show() to display).</li>\n<li><strong>Axes</strong>: Containing the plots (arrange custom summary).</li>\n</ul>\n", "signature": "(\n    self,\n    **kwargs\n) -> (<class 'matplotlib.figure.Figure'>, <class 'matplotlib.axes._axes.Axes'>)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests", "modulename": "Fumagalli_Motta_Tarantino_2020.tests", "type": "module", "doc": "<h1 id=\"explanations-about-the-unittests\">Explanations about the Unittests</h1>\n\n<p>In this file the different Test cases used, are explained. Tests written in bold letters are not yet implemented, but needed for full coverage.</p>\n\n<h2 id=\"glossary-about-the-naming-of-tests\">Glossary about the naming of tests</h2>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:left;\">Part of name</th>\n  <th style=\"text-align:left;\">Remark</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:left;\"><em>not_profitable</em></td>\n  <td style=\"text-align:left;\">$p(\\pi^M_I-\\pi^m_I) &lt; K$ is satisfied</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\"><em>profitable</em></td>\n  <td style=\"text-align:left;\">$p(\\pi^M_I-\\pi^m_I) \\ge K$ is satisfied</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\"><em>below_assets_threshold</em></td>\n  <td style=\"text-align:left;\">$F &lt; \\Phi$ is satisfied</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\"><em>above_assets_threshold</em></td>\n  <td style=\"text-align:left;\">$F \\ge \\Phi$ is satisfied</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\"><em>credit_rationed</em></td>\n  <td style=\"text-align:left;\">The start-up is credit constraint</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\"><em>not_credit_rationed</em></td>\n  <td style=\"text-align:left;\">The start-up is not credit constraint</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\"><em>unsuccessful</em></td>\n  <td style=\"text-align:left;\">The development (if it will take place) is unsuccessful, otherwise we will assume the development was successful</td>\n</tr>\n</tbody>\n</table>\n\n<p>$F$ may correspond to $F(\\bar{A})$ or $F(\\bar{A}^T)$ and $\\Phi$ to $\\Phi(\\cdot)$, $\\Phi^\\prime(\\cdot)$ or $\\Phi^T(\\cdot)$.</p>\n\n<h2 id=\"mocks\">Mocks</h2>\n\n<p>MockModels provides a stub for the OptimalMergerPolicy - class, this is used to test classes for visualizations independently\nof the implementation of the models.</p>\n\n<h2 id=\"testbasemodel\">TestBaseModel</h2>\n\n<p>This testcase test, whether Fumagalli_Motta_Tarantino_2020.Models.BaseModel works as expected.</p>\n\n<p>This testcase includes tests for the following matters:</p>\n\n<ul>\n<li>Test properties (public access for private variables)</li>\n<li>Test necessary conditions for correct values (see pre- and post-conditions)</li>\n</ul>\n\n<h2 id=\"testmergerpolicymodel\">TestMergerPolicyModel</h2>\n\n<p>This  testcase tests, whether Fumagalli_Motta_Tarantino_2020.Models.MergerPolicy properly works.</p>\n\n<h3 id=\"testlaissezfairemergerpolicymodel\">TestLaissezFaireMergerPolicyModel</h3>\n\n<p>This testcase tests, whether the implemented logic for a laissez-faire merger policy works as expected. The following tests are included:</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:left;\">Name of test</th>\n  <th style=\"text-align:center;\">Is the start-up credit rationed?</th>\n  <th style=\"text-align:center;\">Early bidding type (t=1)</th>\n  <th style=\"text-align:center;\">Late bidding type (t=2)</th>\n  <th style=\"text-align:center;\">Development attempt?</th>\n  <th style=\"text-align:center;\">Development success</th>\n  <th style=\"text-align:center;\">Early takeover (t=1)</th>\n  <th style=\"text-align:center;\">Late takeover (t=2)</th>\n  <th style=\"text-align:center;\">Killer Acquisition?</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_below_assets_threshold_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_above_assets_threshold_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_above_assets_threshold_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_below_assets_threshold_not_credit_rationed_unsuccessful</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_not_credit_rationed_unsuccessful</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n</tbody>\n</table>\n\n<h3 id=\"testintermediatelatetakeoverallowedmergerpolicymodel\">TestIntermediateLateTakeoverAllowedMergerPolicyModel</h3>\n\n<p>This testcase tests, whether the implemented logic for an intermediate merger policy (late takeovers are allowed) works as expected. The following tests are included:</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:left;\">Name of test</th>\n  <th style=\"text-align:center;\">Is the start-up credit rationed?</th>\n  <th style=\"text-align:center;\">Early bidding type (t=1)</th>\n  <th style=\"text-align:center;\">Late bidding type (t=2)</th>\n  <th style=\"text-align:center;\">Development attempt?</th>\n  <th style=\"text-align:center;\">Development success</th>\n  <th style=\"text-align:center;\">Early takeover (t=1)</th>\n  <th style=\"text-align:center;\">Late takeover (t=2)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_not_credit_rationed_unsuccessful</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_not_credit_rationed_unsuccessful</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n</tbody>\n</table>\n\n<h3 id=\"testintermediatelatetakeoverprohibitedmergerpolicymodel\">TestIntermediateLateTakeoverProhibitedMergerPolicyModel</h3>\n\n<p>This testcase tests, whether the implemented logic for an intermediate merger policy (late takeovers are prohibited) works as expected. The following tests are included:</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:left;\">Name of test</th>\n  <th style=\"text-align:center;\">Is the start-up credit rationed?</th>\n  <th style=\"text-align:center;\">Early bidding type (t=1)</th>\n  <th style=\"text-align:center;\">Late bidding type (t=2)</th>\n  <th style=\"text-align:center;\">Development attempt?</th>\n  <th style=\"text-align:center;\">Development success</th>\n  <th style=\"text-align:center;\">Early takeover (t=1)</th>\n  <th style=\"text-align:center;\">Late takeover (t=2)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_below_assets_threshold_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_above_assets_threshold_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_above_assets_threshold_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_above_assets_threshold_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_below_assets_threshold_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_below_assets_threshold_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n</tbody>\n</table>\n\n<h3 id=\"teststrictmergerpolicymodel\">TestStrictMergerPolicyModel</h3>\n\n<p>This testcase tests, whether the implemented logic for a strict merger policy works as expected. The following tests are included:</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:left;\">New Name of test</th>\n  <th style=\"text-align:center;\">Is the start-up credit rationed?</th>\n  <th style=\"text-align:center;\">Early bidding type (t=1)</th>\n  <th style=\"text-align:center;\">Late bidding type (t=2)</th>\n  <th style=\"text-align:center;\">Development attempt?</th>\n  <th style=\"text-align:center;\">Development success</th>\n  <th style=\"text-align:center;\">Early takeover (t=1)</th>\n  <th style=\"text-align:center;\">Late takeover (t=2)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_below_assets_threshold_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_below_assets_threshold_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_above_assets_threshold_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_above_assets_threshold_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"testoptimalmergerpolicymodel\">TestOptimalMergerPolicyModel</h2>\n\n<p>This testcase tests all possibilities for an optimal merger policy in Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.</p>\n\n<h2 id=\"testmircofoundationmodel\">TestMircoFoundationModel</h2>\n\n<p>This testcase tests the adjustments made for the Fumagalli_Motta_Tarantino_2020.AdditionalModels.MicroFoundationModel, which is largely based on the OptimalMergerPolicyModel.</p>\n\n<h2 id=\"testperfectinformationmodel\">TestPerfectInformationModel</h2>\n\n<p>This testcase tests, whether the implemented logic in Fumagalli_Motta_Tarantino_2020.AdditionalModels.PerfectInformationModel works as expected.</p>\n\n<h3 id=\"teststrictperfectinformationmodel\">TestStrictPerfectInformationModel</h3>\n\n<p>This testcase tests, whether the implemented logic in Fumagalli_Motta_Tarantino_2020.AdditionalModels.PerfectInformationModel for a strict merger policy works as expected. The following tests are included:</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:left;\">Name of test</th>\n  <th style=\"text-align:center;\">Is the start-up credit rationed?</th>\n  <th style=\"text-align:center;\">Early bidding type (t=1)</th>\n  <th style=\"text-align:center;\">Late bidding type (t=2)</th>\n  <th style=\"text-align:center;\">Development attempt?</th>\n  <th style=\"text-align:center;\">Development success</th>\n  <th style=\"text-align:center;\">Early takeover (t=1)</th>\n  <th style=\"text-align:center;\">Late takeover (t=2)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n</tbody>\n</table>\n\n<h3 id=\"testintermediateperfectinformationmodel\">TestIntermediatePerfectInformationModel</h3>\n\n<p>This testcase tests, whether the implemented logic in Fumagalli_Motta_Tarantino_2020.AdditionalModels.PerfectInformationModel for an intermediate merger policy (late takeovers are allowed) works as expected. The following tests are included:</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:left;\">Name of test</th>\n  <th style=\"text-align:center;\">Is the start-up credit rationed?</th>\n  <th style=\"text-align:center;\">Early bidding type (t=1)</th>\n  <th style=\"text-align:center;\">Late bidding type (t=2)</th>\n  <th style=\"text-align:center;\">Development attempt?</th>\n  <th style=\"text-align:center;\">Development success</th>\n  <th style=\"text-align:center;\">Early takeover (t=1)</th>\n  <th style=\"text-align:center;\">Late takeover (t=2)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">True</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_not_credit_rationed_unsuccessful</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n</tbody>\n</table>\n\n<h3 id=\"testlaissezfaireperfectinformationmodel\">TestLaissezFairePerfectInformationModel</h3>\n\n<p>This testcase tests, whether the implemented logic in Fumagalli_Motta_Tarantino_2020.AdditionalModels.PerfectInformationModel for a laissez-faire merger policy works as expected. The following tests are included:</p>\n\n<table>\n<thead>\n<tr>\n  <th style=\"text-align:left;\">Name of test</th>\n  <th style=\"text-align:center;\">Is the start-up credit rationed?</th>\n  <th style=\"text-align:center;\">Early bidding type (t=1)</th>\n  <th style=\"text-align:center;\">Late bidding type (t=2)</th>\n  <th style=\"text-align:center;\">Development attempt?</th>\n  <th style=\"text-align:center;\">Development success</th>\n  <th style=\"text-align:center;\">Early takeover (t=1)</th>\n  <th style=\"text-align:center;\">Late takeover (t=2)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_not_profitable_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_not_credit_rationed</td>\n  <td style=\"text-align:center;\">False</td>\n  <td style=\"text-align:center;\">Pooling</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n<tr>\n  <td style=\"text-align:left;\">test_profitable_credit_rationed</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Separating</td>\n  <td style=\"text-align:center;\">No</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">Does not matter</td>\n  <td style=\"text-align:center;\">True</td>\n  <td style=\"text-align:center;\">False</td>\n</tr>\n</tbody>\n</table>\n\n<h2 id=\"testvisualize\">TestVisualize</h2>\n\n<p>This testcase test the plots in Fumagalli_Motta_Tarantino_2020.Visualization made with mock objects. The plots are tested by eye, since currently no method exists, to write\nstable unitest for matplotlib. </p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.MockModels", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.MockModels", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.MockModels.mock_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.MockModels", "qualname": "mock_optimal_merger_policy", "type": "function", "doc": "<p>Creates a mock model of Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy.</p>\n", "signature": "(\n    asset_threshold: float = 0.5,\n    asset_threshold_late_takeover: float = -1,\n    credit_constrained: bool = False,\n    policy: Fumagalli_Motta_Tarantino_2020.Types.MergerPolicies = <MergerPolicies.Intermediate_late_takeover_prohibited: 'Intermediate (late takeover prohibited)'>,\n    **kwargs\n) -> Fumagalli_Motta_Tarantino_2020.Models.OptimalMergerPolicy", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestOptimalMergerPolicyModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.setUp", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.setUp", "type": "function", "doc": "<p>Hook method for setting up the test fixture before exercising it.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.setupModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.setupModel", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.calculate_properties_profits_consumer_surplus", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.calculate_properties_profits_consumer_surplus", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.get_welfare_value", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.get_welfare_value", "type": "function", "doc": "<p></p>\n", "signature": "(self, market_situation: str, **kwargs) -> float", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.test_properties_profits_consumer_surplus", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.test_properties_profits_consumer_surplus", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.test_intermediate_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.test_intermediate_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.test_string_representation", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.test_string_representation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.test_laissez_faire_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.test_laissez_faire_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.test_tolerated_harm_strict", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.test_tolerated_harm_strict", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.test_tolerated_harm_intermediate_late_takeover_allowed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.test_tolerated_harm_intermediate_late_takeover_allowed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.test_tolerated_harm_intermediate_late_takeover_prohibited", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.test_tolerated_harm_intermediate_late_takeover_prohibited", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestMircoFoundationModel.test_tolerated_harm_laissez_faire", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestMircoFoundationModel.test_tolerated_harm_laissez_faire", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestPerfectInformationModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestPerfectInformationModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestOptimalMergerPolicyModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestPerfectInformationModel.setupModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestPerfectInformationModel.setupModel", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestPerfectInformationModel.test_tolerated_harm_intermediate_late_takeover_allowed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestPerfectInformationModel.test_tolerated_harm_intermediate_late_takeover_allowed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestPerfectInformationModel.test_set_invalid_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestPerfectInformationModel.test_set_invalid_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestPerfectInformationModel.test_laissez_faire_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestPerfectInformationModel.test_laissez_faire_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestStrictPerfectInformationModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestStrictPerfectInformationModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestPerfectInformationModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestStrictPerfectInformationModel.test_not_profitable_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestStrictPerfectInformationModel.test_not_profitable_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestStrictPerfectInformationModel.test_not_profitable_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestStrictPerfectInformationModel.test_not_profitable_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestStrictPerfectInformationModel.test_profitable_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestStrictPerfectInformationModel.test_profitable_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestStrictPerfectInformationModel.test_profitable_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestStrictPerfectInformationModel.test_profitable_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestIntermediatePerfectInformationModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestIntermediatePerfectInformationModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestPerfectInformationModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestIntermediatePerfectInformationModel.test_not_profitable_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestIntermediatePerfectInformationModel.test_not_profitable_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestIntermediatePerfectInformationModel.test_not_profitable_not_credit_rationed_unsuccessful", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestIntermediatePerfectInformationModel.test_not_profitable_not_credit_rationed_unsuccessful", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestIntermediatePerfectInformationModel.test_profitable_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestIntermediatePerfectInformationModel.test_profitable_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestIntermediatePerfectInformationModel.test_profitable_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestIntermediatePerfectInformationModel.test_profitable_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestLaissezFairePerfectInformationModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestLaissezFairePerfectInformationModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestPerfectInformationModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestLaissezFairePerfectInformationModel.test_not_profitable_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestLaissezFairePerfectInformationModel.test_not_profitable_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestLaissezFairePerfectInformationModel.test_not_profitable_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestLaissezFairePerfectInformationModel.test_not_profitable_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestLaissezFairePerfectInformationModel.test_profitable_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestLaissezFairePerfectInformationModel.test_profitable_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestLaissezFairePerfectInformationModel.test_profitable_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestLaissezFairePerfectInformationModel.test_profitable_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestEquityModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestEquityModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestOptimalMergerPolicyModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestEquityModel.setupModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestEquityModel.setupModel", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestEquityModel.test_thresholds", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestEquityModel.test_thresholds", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestEquityModel.test_debt_not_preferred", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestEquityModel.test_debt_not_preferred", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestEquityModel.test_debt_preferred", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestEquityModel.test_debt_preferred", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestEquityModel.test_intermediate_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestEquityModel.test_intermediate_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels.TestEquityModel.test_laissez_faire_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_AdditionalModels", "qualname": "TestEquityModel.test_laissez_faire_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations.TestLoadParameters", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations", "qualname": "TestLoadParameters", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "unittest.case.TestCase"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations.TestLoadParameters.setUpModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations", "qualname": "TestLoadParameters.setUpModel", "type": "function", "doc": "<p></p>\n", "signature": "(self, config_id: int)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations.TestLoadParameters.test_config_loading", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations", "qualname": "TestLoadParameters.test_config_loading", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations.TestLoadParameters.test_startup_assets", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations", "qualname": "TestLoadParameters.test_startup_assets", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations.TestLoadParameters.test_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations", "qualname": "TestLoadParameters.test_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations.TestLoadParameters.test_toggle_development_success", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations", "qualname": "TestLoadParameters.test_toggle_development_success", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations.TestLoadParameters.test_adjust_parameter", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations", "qualname": "TestLoadParameters.test_adjust_parameter", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations.TestLoadParameters.test_load_unavailable_id", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Configurations", "qualname": "TestLoadParameters.test_load_unavailable_id", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestProCompetitive", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestProCompetitive", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestOptimalMergerPolicyModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestProCompetitive.setupModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestProCompetitive.setupModel", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestProCompetitive.test_tolerated_harm_strict", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestProCompetitive.test_tolerated_harm_strict", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestProCompetitive.test_tolerated_harm_intermediate_late_takeover_prohibited", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestProCompetitive.test_tolerated_harm_intermediate_late_takeover_prohibited", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestProCompetitive.test_tolerated_harm_intermediate_late_takeover_allowed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestProCompetitive.test_tolerated_harm_intermediate_late_takeover_allowed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestProCompetitive.test_laissez_faire_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestProCompetitive.test_laissez_faire_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestProCompetitive.test_intermediate_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestProCompetitive.test_intermediate_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestProCompetitive.test_strict_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestProCompetitive.test_strict_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestStrictProCompetitive", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestStrictProCompetitive", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestProCompetitive"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestStrictProCompetitive.test_not_profitable", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestStrictProCompetitive.test_not_profitable", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestIntermediateLateTakeoverProhibitedProCompetitive", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestIntermediateLateTakeoverProhibitedProCompetitive", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestProCompetitive"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestIntermediateLateTakeoverProhibitedProCompetitive.test_not_profitable_above_threshold", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestIntermediateLateTakeoverProhibitedProCompetitive.test_not_profitable_above_threshold", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestIntermediateLateTakeoverProhibitedProCompetitive.test_not_profitable_below_threshold", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestIntermediateLateTakeoverProhibitedProCompetitive.test_not_profitable_below_threshold", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestIntermediateLateTakeoverAllowedProCompetitive", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestIntermediateLateTakeoverAllowedProCompetitive", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestProCompetitive"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestIntermediateLateTakeoverAllowedProCompetitive.test_not_profitable_above_threshold_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestIntermediateLateTakeoverAllowedProCompetitive.test_not_profitable_above_threshold_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestIntermediateLateTakeoverAllowedProCompetitive.test_not_profitable_above_threshold_not_credit_rationed_unsuccessful", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestIntermediateLateTakeoverAllowedProCompetitive.test_not_profitable_above_threshold_not_credit_rationed_unsuccessful", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestIntermediateLateTakeoverAllowedProCompetitive.test_not_profitable_above_threshold_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestIntermediateLateTakeoverAllowedProCompetitive.test_not_profitable_above_threshold_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestIntermediateLateTakeoverAllowedProCompetitive.test_not_profitable_below_threshold", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestIntermediateLateTakeoverAllowedProCompetitive.test_not_profitable_below_threshold", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestResourceWaste", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestResourceWaste", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestProCompetitive"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestResourceWaste.setupModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestResourceWaste.setupModel", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestResourceWaste.test_tolerated_harm_intermediate_late_takeover_prohibited", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestResourceWaste.test_tolerated_harm_intermediate_late_takeover_prohibited", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestResourceWaste.test_string_representation", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestResourceWaste.test_string_representation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestResourceWaste.test_not_profitable_above_threshold", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestResourceWaste.test_not_profitable_above_threshold", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestResourceWaste.test_not_profitable_below_threshold", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestResourceWaste.test_not_profitable_below_threshold", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestResourceWaste.test_intermediate_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestResourceWaste.test_intermediate_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestResourceWaste.test_laissez_faire_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestResourceWaste.test_laissez_faire_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestResourceWaste.test_strict_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestResourceWaste.test_strict_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels.TestResourceWaste.test_strict_optimal_merger_policy_summary", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_ExtensionModels", "qualname": "TestResourceWaste.test_strict_optimal_merger_policy_summary", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.CoreTest", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "CoreTest", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "unittest.case.TestCase"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.CoreTest.are_floats_equal", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "CoreTest.are_floats_equal", "type": "function", "doc": "<p></p>\n", "signature": "(f1: float, f2: float, tolerance: float = 1e-10) -> float", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.CoreTest.get_default_value", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "CoreTest.get_default_value", "type": "function", "doc": "<p></p>\n", "signature": "(\n    arg_name: str,\n    model=<class 'Fumagalli_Motta_Tarantino_2020.Models.BaseModel'>\n) -> float", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.CoreTest.get_welfare_value", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "CoreTest.get_welfare_value", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    market_situation: str,\n    model=<class 'Fumagalli_Motta_Tarantino_2020.Models.BaseModel'>\n) -> float", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestBaseModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestBaseModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "CoreTest"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestBaseModel.setupModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestBaseModel.setupModel", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestBaseModel.setUpConfiguration", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestBaseModel.setUpConfiguration", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    config_id: int,\n    merger_policy=<MergerPolicies.Strict: 'Strict'>,\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestBaseModel.test_valid_setup_default_values", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestBaseModel.test_valid_setup_default_values", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestBaseModel.test_uniform_distribution", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestBaseModel.test_uniform_distribution", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestBaseModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.setUp", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.setUp", "type": "function", "doc": "<p>Hook method for setting up the test fixture before exercising it.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.get_model_type", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.get_model_type", "type": "function", "doc": "<p></p>\n", "signature": "()", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.abstract_property_test", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.abstract_property_test", "type": "function", "doc": "<p></p>\n", "signature": "(self, property_, property_name, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_development_costs", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_development_costs", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_startup_assets", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_startup_assets", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_success_probability", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_success_probability", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_private_benefit", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_private_benefit", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_incumbent_profit_without_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_incumbent_profit_without_innovation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_incumbent_profit_duopoly", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_incumbent_profit_duopoly", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_incumbent_profit_with_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_incumbent_profit_with_innovation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_startup_profit_duopoly", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_startup_profit_duopoly", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_consumer_surplus_with_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_consumer_surplus_with_innovation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_consumer_surplus_without_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_consumer_surplus_without_innovation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_consumer_surplus_duopoly", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_consumer_surplus_duopoly", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_welfare_without_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_welfare_without_innovation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_welfare_with_innovation", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_welfare_with_innovation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_welfare_duopoly", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_welfare_duopoly", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_development_success", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_development_success", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestProperties.test_invalid_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestProperties.test_invalid_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestMergerPolicyModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestMergerPolicyModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestBaseModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestMergerPolicyModel.setupModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestMergerPolicyModel.setupModel", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestMergerPolicyModel.test_tolerated_harm_strict", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestMergerPolicyModel.test_tolerated_harm_strict", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestMergerPolicyModel.test_tolerated_harm_intermediate_late_takeover_allowed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestMergerPolicyModel.test_tolerated_harm_intermediate_late_takeover_allowed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestMergerPolicyModel.test_tolerated_harm_intermediate_late_takeover_prohibited", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestMergerPolicyModel.test_tolerated_harm_intermediate_late_takeover_prohibited", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestMergerPolicyModel.test_tolerated_harm_laissez_faire", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestMergerPolicyModel.test_tolerated_harm_laissez_faire", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestLaissezFaireMergerPolicyModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestLaissezFaireMergerPolicyModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestMergerPolicyModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestLaissezFaireMergerPolicyModel.test_not_profitable_below_assets_threshold_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestLaissezFaireMergerPolicyModel.test_not_profitable_below_assets_threshold_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestLaissezFaireMergerPolicyModel.test_not_profitable_above_assets_threshold_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestLaissezFaireMergerPolicyModel.test_not_profitable_above_assets_threshold_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestLaissezFaireMergerPolicyModel.test_not_profitable_above_assets_threshold_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestLaissezFaireMergerPolicyModel.test_not_profitable_above_assets_threshold_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestLaissezFaireMergerPolicyModel.test_not_profitable_below_assets_threshold_not_credit_rationed_unsuccessful", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestLaissezFaireMergerPolicyModel.test_not_profitable_below_assets_threshold_not_credit_rationed_unsuccessful", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestLaissezFaireMergerPolicyModel.test_profitable_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestLaissezFaireMergerPolicyModel.test_profitable_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestLaissezFaireMergerPolicyModel.test_profitable_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestLaissezFaireMergerPolicyModel.test_profitable_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestLaissezFaireMergerPolicyModel.test_profitable_not_credit_rationed_unsuccessful", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestLaissezFaireMergerPolicyModel.test_profitable_not_credit_rationed_unsuccessful", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverAllowedMergerPolicyModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverAllowedMergerPolicyModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestMergerPolicyModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_not_profitable_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_not_profitable_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_not_profitable_not_credit_rationed_unsuccessful", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_not_profitable_not_credit_rationed_unsuccessful", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_not_profitable_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_not_profitable_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_profitable_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_profitable_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_profitable_not_credit_rationed_unsuccessful", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_profitable_not_credit_rationed_unsuccessful", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_profitable_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverAllowedMergerPolicyModel.test_profitable_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverProhibitedMergerPolicyModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverProhibitedMergerPolicyModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestMergerPolicyModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_not_profitable_below_assets_threshold_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_not_profitable_below_assets_threshold_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_not_profitable_above_assets_threshold_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_not_profitable_above_assets_threshold_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_profitable_below_assets_threshold_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_profitable_below_assets_threshold_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_profitable_below_assets_threshold_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_profitable_below_assets_threshold_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_profitable_above_assets_threshold_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_profitable_above_assets_threshold_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_profitable_above_assets_threshold_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestIntermediateLateTakeoverProhibitedMergerPolicyModel.test_profitable_above_assets_threshold_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestStrictMergerPolicyModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestStrictMergerPolicyModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestMergerPolicyModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestStrictMergerPolicyModel.test_not_profitable_not_credit_rationed_summary", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestStrictMergerPolicyModel.test_not_profitable_not_credit_rationed_summary", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestStrictMergerPolicyModel.test_not_profitable_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestStrictMergerPolicyModel.test_not_profitable_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestStrictMergerPolicyModel.test_not_profitable_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestStrictMergerPolicyModel.test_not_profitable_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestStrictMergerPolicyModel.test_set_startup_assets_recalculation", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestStrictMergerPolicyModel.test_set_startup_assets_recalculation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestStrictMergerPolicyModel.test_set_tolerated_harm_recalculation", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestStrictMergerPolicyModel.test_set_tolerated_harm_recalculation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestStrictMergerPolicyModel.test_set_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestStrictMergerPolicyModel.test_set_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestStrictMergerPolicyModel.test_profitable_below_assets_threshold_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestStrictMergerPolicyModel.test_profitable_below_assets_threshold_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestStrictMergerPolicyModel.test_profitable_below_assets_threshold_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestStrictMergerPolicyModel.test_profitable_below_assets_threshold_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestStrictMergerPolicyModel.test_profitable_above_assets_threshold_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestStrictMergerPolicyModel.test_profitable_above_assets_threshold_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestStrictMergerPolicyModel.test_profitable_above_assets_threshold_not_credit_rationed", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestStrictMergerPolicyModel.test_profitable_above_assets_threshold_not_credit_rationed", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestOptimalMergerPolicyModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestOptimalMergerPolicyModel", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestMergerPolicyModel"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestOptimalMergerPolicyModel.setupModel", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestOptimalMergerPolicyModel.setupModel", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestOptimalMergerPolicyModel.test_strict_optimal_merger_policy_summary", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestOptimalMergerPolicyModel.test_strict_optimal_merger_policy_summary", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestOptimalMergerPolicyModel.test_strict_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestOptimalMergerPolicyModel.test_strict_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestOptimalMergerPolicyModel.test_intermediate_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestOptimalMergerPolicyModel.test_intermediate_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestOptimalMergerPolicyModel.test_laissez_faire_optimal_merger_policy", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestOptimalMergerPolicyModel.test_laissez_faire_optimal_merger_policy", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models.TestOptimalMergerPolicyModel.test_string_representation", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Models", "qualname": "TestOptimalMergerPolicyModel.test_string_representation", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types.TestThresholdItem", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types", "qualname": "TestThresholdItem", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "unittest.case.TestCase"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types.TestThresholdItem.test_comparison_true_unequal", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types", "qualname": "TestThresholdItem.test_comparison_true_unequal", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types.TestThresholdItem.test_comparison_false_unequal", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types", "qualname": "TestThresholdItem.test_comparison_false_unequal", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types.TestThresholdItem.test_comparison_true_equal", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types", "qualname": "TestThresholdItem.test_comparison_true_equal", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types.TestThresholdItem.test_comparison_false_equal", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types", "qualname": "TestThresholdItem.test_comparison_false_equal", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types.TestThresholdItem.test_max_list", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types", "qualname": "TestThresholdItem.test_max_list", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types.TestThresholdItem.test_min_list", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types", "qualname": "TestThresholdItem.test_min_list", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types.TestThresholdItem.test_include", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Types", "qualname": "TestThresholdItem.test_include", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities.TestNormalDistributionFunction", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "qualname": "TestNormalDistributionFunction", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "unittest.case.TestCase"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities.TestNormalDistributionFunction.test_cumulative_function", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "qualname": "TestNormalDistributionFunction.test_cumulative_function", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities.TestNormalDistributionFunction.test_cumulative_function_adjusted_scale", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "qualname": "TestNormalDistributionFunction.test_cumulative_function_adjusted_scale", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities.TestNormalDistributionFunction.test_inverse_cumulative_function", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "qualname": "TestNormalDistributionFunction.test_inverse_cumulative_function", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities.TestNormalDistributionFunction.test_inverse_cumulative_function_adjusted_loc", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "qualname": "TestNormalDistributionFunction.test_inverse_cumulative_function_adjusted_loc", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities.TestUniformDistributionFunction", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "qualname": "TestUniformDistributionFunction", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "TestNormalDistributionFunction"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities.TestUniformDistributionFunction.test_cumulative_function", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "qualname": "TestUniformDistributionFunction.test_cumulative_function", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities.TestUniformDistributionFunction.test_cumulative_function_adjusted_scale", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "qualname": "TestUniformDistributionFunction.test_cumulative_function_adjusted_scale", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities.TestUniformDistributionFunction.test_inverse_cumulative_function", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "qualname": "TestUniformDistributionFunction.test_inverse_cumulative_function", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities.TestUniformDistributionFunction.test_inverse_cumulative_function_adjusted_loc", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Utilities", "qualname": "TestUniformDistributionFunction.test_inverse_cumulative_function_adjusted_loc", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "type": "module", "doc": "<p></p>\n"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize", "type": "class", "doc": "<p>A class whose instances are single test cases.</p>\n\n<p>By default, the test code itself should be placed in a method named\n'runTest'.</p>\n\n<p>If the fixture may be used for many test cases, create as\nmany test methods as are needed. When instantiating such a TestCase\nsubclass, specify in the constructor arguments the name of the test method\nthat the instance is to execute.</p>\n\n<p>Test authors should subclass TestCase for their own tests. Construction\nand deconstruction of the test's environment ('fixture') can be\nimplemented by overriding the 'setUp' and 'tearDown' methods respectively.</p>\n\n<p>If it is necessary to override the __init__ method, the base class\n__init__ method must always be called. It is important that subclasses\nshould not change the signature of their __init__ method, since instances\nof the classes are instantiated automatically by parts of the framework\nin order to be run.</p>\n\n<p>When subclassing TestCase, you can set these attributes:</p>\n\n<ul>\n<li>failureException: determines which exception will be raised when\nthe instance's assertion methods fail; test methods raising this\nexception will be deemed to have 'failed' rather than 'errored'.</li>\n<li>longMessage: determines whether long messages (including repr of\nobjects used in assert methods) will be printed on failure in <em>addition</em>\nto any explicit message passed.</li>\n<li>maxDiff: sets the maximum length of a diff in failure messages\nby assert methods using difflib. It is looked up as an instance\nattribute so can be configured by individual tests if required.</li>\n</ul>\n", "bases": "unittest.case.TestCase"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.show_all", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.show_all", "type": "variable", "doc": "<p></p>\n", "annotation": ": bool", "default_value": " = False"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.setUp", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.setUp", "type": "function", "doc": "<p>Hook method for setting up the test fixture before exercising it.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.setUpMock", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.setUpMock", "type": "function", "doc": "<p></p>\n", "signature": "(self, **kwargs) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.setUpVisualizerCall", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.setUpVisualizerCall", "type": "function", "doc": "<p></p>\n", "signature": "(\n    self,\n    plot_type: Callable,\n    show_plot: bool = False,\n    never_show_plot: bool = False,\n    show_plot_now: bool = False,\n    **kwargs\n) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.tearDown", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.tearDown", "type": "function", "doc": "<p>Hook method for deconstructing the test fixture after testing it.</p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.show_figure", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.show_figure", "type": "function", "doc": "<p></p>\n", "signature": "(self) -> None", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_plot_interface", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_plot_interface", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_essential_asset_thresholds", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_essential_asset_thresholds", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_essential_asset_thresholds_negative_values", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_essential_asset_thresholds_negative_values", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_outcomes_asset_range", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_outcomes_asset_range", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_asset_range_plot_negative_threshold", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_asset_range_plot_negative_threshold", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_asset_range_plot", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_asset_range_plot", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_asset_range_set_model", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_asset_range_set_model", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_outcomes_merger_policies", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_outcomes_merger_policies", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_merger_policies_plot", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_merger_policies_plot", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_timeline_plot", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_timeline_plot", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_timeline_plot_takeover_development_not_successful", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_timeline_plot_takeover_development_not_successful", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_timeline_plot_takeover_shelving_credit_constraint", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_timeline_plot_takeover_shelving_credit_constraint", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_timeline_set_model", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_timeline_set_model", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_payoff_plot", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_payoff_plot", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_overview_plot", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_overview_plot", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_perfect_information_asset_range", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_perfect_information_asset_range", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}, {"fullname": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize.TestVisualize.test_perfect_information_overview", "modulename": "Fumagalli_Motta_Tarantino_2020.tests.Test_Visualize", "qualname": "TestVisualize.test_perfect_information_overview", "type": "function", "doc": "<p></p>\n", "signature": "(self)", "funcdef": "def"}];

    // mirrored in build-search-index.js (part 1)
    // Also split on html tags. this is a cheap heuristic, but good enough.
    elasticlunr.tokenizer.setSeperator(/[\s\-.;&_'"=,()]+|<[^>]*>/);

    let searchIndex;
    if (docs._isPrebuiltIndex) {
        console.info("using precompiled search index");
        searchIndex = elasticlunr.Index.load(docs);
    } else {
        console.time("building search index");
        // mirrored in build-search-index.js (part 2)
        searchIndex = elasticlunr(function () {
            this.pipeline.remove(elasticlunr.stemmer);
            this.pipeline.remove(elasticlunr.stopWordFilter);
            this.addField("qualname");
            this.addField("fullname");
            this.addField("annotation");
            this.addField("default_value");
            this.addField("signature");
            this.addField("bases");
            this.addField("doc");
            this.setRef("fullname");
        });
        for (let doc of docs) {
            searchIndex.addDoc(doc);
        }
        console.timeEnd("building search index");
    }

    return (term) => searchIndex.search(term, {
        fields: {
            qualname: {boost: 4},
            fullname: {boost: 2},
            annotation: {boost: 2},
            default_value: {boost: 2},
            signature: {boost: 2},
            bases: {boost: 2},
            doc: {boost: 1},
        },
        expand: true
    });
})();